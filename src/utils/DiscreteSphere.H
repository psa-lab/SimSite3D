/******************************************************************************
 * Copyright (c) 2006,2007, Michigan State University (MSU) Board of Trustees.
 *   All rights reserved.
 *
 * This file is part of the SimSite3D Software project.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Authors: Jeffrey Van Voorst, vanvoor4@msu.edu
 *          Leslie Kuhn, Ph.D., KuhnL@msu.edu 
 *****************************************************************************/

/*
 * $Source: /psa/share/repository/pfizer_proj/src/basics/DiscreteSphere.H,v $
 * $Revision: 1.2 $
 * $Author: vanvoor4 $
 * $Date: 2008-04-17 18:36:06 $
 * 
 * $Log: not supported by cvs2svn $
 * Revision 1.1  2007/12/17 21:10:00  vanvoor4
 * Initial checkin
 *
 *
 */

#ifndef SIMSITE3D_SPHERE_SURF_SAMPLE_PTS_INCLUDED
#define SIMSITE3D_SPHERE_SURF_SAMPLE_PTS_INCLUDED

#include <types.H>

namespace SimSite3D{

  typedef enum{
    DISCRETE_SPHERE_LEVEL_ZERO,
    DISCRETE_SPHERE_LEVEL_ONE,
    DISCRETE_SPHERE_LEVEL_TWO,
    DISCRETE_SPHERE_LEVEL_THREE
  }sphere_sample_level_t;

  //! Discretize a 1 (A) sphere with the points well distributed (almost
  //! homogeneous)
  /*! The method used to generate the 4 sets of points is given in the 
   * reference:  Kurihara, Yoshio, "Numerical integration of the primitive 
   * equations on a spherical grid", MONTHLY WEATHER REVIEW, 93(7), July, 1965.
   *
   * The discrete spheres were generated by starting with a base representation
   * of 10 points (level 0).  The approximate distance between points was 
   * reduced till additional points appeared.  This was repeated twice more to 
   * obtain the 4 levels of discrete sampling of a sphere with 1 (A) radius 
   * centered at the origin (0,0,0).
   * 
   * One nicety is that the points in level 1 correspond to the same points as 
   * those generated by starting with 2 (square) pyramids to represent a sphere,
   * (octahedron)
   * halving each original edge and pushing each additional point out till
   * it sits on the sphere.
   */
  class DiscreteSphere{
  public:    
    //! Cstor;  sets the sphere level
    DiscreteSphere(sphere_sample_level_t lvl = DISCRETE_SPHERE_LEVEL_TWO);

    //! Apply the given transformation to the copy
    DiscreteSphere(const DiscreteSphere& src, const my_float_t* R,  
                   const my_float_t* T);

    //! Basic Dstor
    ~DiscreteSphere()
    { 
      if(A_pts) delete[] A_pts;
      A_pts = 0;
    }

    //! Scale the current sphere by s
    void 
    scale(my_float_t s)
    {
      if(A_pts == 0) create_copy(A_orig_pts, &A_pts);
      my_float_t* pt = A_pts;
      if(A_center[0] == 0.0 && A_center[1] == 0.0 && A_center[2] == 0.0){
        for(uint i = 0; i < 3*A_num_pts; ++i, ++pt) *pt *= s;
      }else{
        my_float_t* c = 0;
        for(uint i = 0; i < A_num_pts; ++i){
          c = A_center;
          for(uint j = 0; j < 3; ++j, ++pt, ++c) *pt = s * (*pt - *c) + *c;
        }
      }
    }

    //! Get a constant pointer to the first element of the sphere
    const my_float_t*
    pts_begin() const
    { return (A_pts ? A_pts :  A_orig_pts); }

    //! Get a constant pointer to 1 past the last element of the sphere
    const my_float_t*
    pts_end() const
    { 
      uint my_end = 3*A_num_pts;
      return (A_pts ? A_pts + my_end : A_orig_pts + my_end); 
    }
 
    //! Get the number of points in the array
    const uint
    num_pts() const
    { return A_num_pts; }

  private:
    //! Create a nonconstant copy of the points
    void 
    create_copy(const my_float_t* src, my_float_t** dest);

    const my_float_t* A_orig_pts; //!< The first element of original sphere
    uint A_num_pts;               //!< Number of points in sphere (array)
    my_float_t* A_pts;            //!< Pointer to first coord of first pt 
    my_float_t A_center[3];       //!< Center of the sphere
 
    static const uint level_0_len; //!< Number of points in the 0th level rep
    static const uint level_1_len; //!< Number of points in the 1st level rep
    static const uint level_2_len; //!< Number of points in the 2nd level rep
    static const uint level_3_len; //!< Number of points in the 3rd level rep
    static const my_float_t level_0[]; //!< 0th level rep of 1 (A) sphere
    static const my_float_t level_1[]; //!< 1st level rep of 1 (A) sphere
    static const my_float_t level_2[]; //!< 2nd level rep of 1 (A) sphere
    static const my_float_t level_3[]; //!< 3rd level rep of 1 (A) sphere
  };
}
#endif
