// This file has been generated by Py++.

#include <boost/python.hpp>
#include <hbond_points.H>
#include "__array_1.pypp.hpp"

using namespace boost::python;
using ASCbase::point_t;
using ASCbase::dir_point_t;
using ASCbase::hbond_point_t;
using ASCbase::hbond_ideal_point_t;


struct dir_point_t_wrapper : dir_point_t, wrapper<dir_point_t>{
  dir_point_t_wrapper(dir_point_t const &arg)
    : dir_point_t(arg), wrapper<dir_point_t>(){
    // copy constructor
  }

  dir_point_t_wrapper()
    : dir_point_t(), wrapper<dir_point_t>(){
    // null constructor
  }

  static pyplusplus::containers::static_sized::array_1_t<double, 3>
  pyplusplus_pos_wrapper(dir_point_t &inst){
    return pyplusplus::containers::static_sized::array_1_t<double, 3>(inst.pos);
  }

  static pyplusplus::containers::static_sized::array_1_t<double, 3>
  pyplusplus_dir_wrapper(dir_point_t &inst){
    return pyplusplus::containers::static_sized::array_1_t<double, 3>(inst.dir);
  }
};

// Note one must be careful here since the point_t and additional machinery
// has a nonstandard allocation scheme so that the positions of atoms, etc
// can be stored in a contiguous hunk of memory to allow for rapid operations
// (i.e. transformation of coordinates).

// In particular one should not be creating hbond points or hbond ideal points
// in python but use the C++ extensions to do so
BOOST_PYTHON_MODULE(_hbond_points){
  enum_< ASCbase::interactionType>("interactionType")
    .value("UNKNOWN_INTERACTION", ASCbase::UNKNOWN_INTERACTION)
    .value("ACCEPTOR", ASCbase::ACCEPTOR)
    .value("DONOR", ASCbase::DONOR)
    .value("HYDROPHOB", ASCbase::HYDROPHOB)
    .value("DONEPTOR", ASCbase::DONEPTOR)
    .value("DONOR_HYDROGEN", ASCbase::DONOR_HYDROGEN)
    .value("METAL_1", ASCbase::METAL_1)
    .value("METAL_2", ASCbase::METAL_2)
    .value("HBVEC", ASCbase::HBVEC)
    .value("NOTHING", ASCbase::NOTHING)
    .export_values()
  ;
 
  { // dir_point_t
    typedef class_<dir_point_t_wrapper> dir_point_t_exposer_t;
    dir_point_t_exposer_t dir_point_exposer = 
      dir_point_t_exposer_t("dir_point_t");
    scope dir_point_t_scope(dir_point_exposer);

    pyplusplus::containers::static_sized::register_array_1<double, 3>
      ("__array_1_double_3");
    {  // ASCbase::dir_point_t::dir [variable], type = myfloat_t[3]
      typedef pyplusplus::containers::static_sized::array_1_t<double,3>
        (*array_wrapper_creator)(dir_point_t &);
      dir_point_exposer.add_property("dir",
        make_function(array_wrapper_creator(&dir_point_t_wrapper::pyplusplus_dir_wrapper), 
        with_custodian_and_ward_postcall<0,1>()) );
    }

    { // ASCbase::dir_point_t::pos [variable], type = myfloat_t[3]
      typedef pyplusplus::containers::static_sized::array_1_t<double,3>
        (*array_wrapper_creator)(dir_point_t &);
      dir_point_exposer.add_property("pos",
        make_function(array_wrapper_creator(&dir_point_t_wrapper::pyplusplus_pos_wrapper),
        with_custodian_and_ward_postcall<0,1>()) );

    }
  }

  { // hbond_ideal_point_t
    class_<hbond_ideal_point_t, bases<dir_point_t, point_t> >
      ("hbond_ideal_point")    
      .def_readwrite("pt_num", &hbond_ideal_point_t::pt_num)
      .def_readwrite("act_type", &hbond_ideal_point_t::act_type)
      .def("get_atom", &hbond_ideal_point_t::__get_atom, 
           return_internal_reference<1>())
      .def("get_carbon_nbr", &hbond_ideal_point_t::__get_carbon_nbr,
           return_internal_reference<1>())
    ;
  }

  { // hbond_point_t
    class_<hbond_point_t, bases<dir_point_t, point_t> >
      ("hbond_point")
      .def_readwrite("act_type",  &hbond_point_t::act_type)
      .def("get_atom", &hbond_point_t::__get_atom, 
           return_internal_reference<1>())
      .def("get_ideal_pt", &hbond_point_t::__get_ideal_pt,
           return_internal_reference<1>())
    ;
  }

}

#if 0
// Cannot get this to work at this point -- boost.python is quickly becoming
// a sink for my time --- I cannot afford to be "correct" in terms of 
// placing the code at the right places and not modifying my C++ classes
// to support the interface 
//  
// In particular, I am getting a mismatch error:
/*
Traceback (most recent call last):
  File "test_stuff.py", line 101, in ?
    my_atom = ideal_pt.atom()
Boost.Python.ArgumentError: Python argument types in
    hbond_ideal_point.atom(hbond_ideal_point)
did not match C++ signature:
    atom(hbond_ideal_point_t_wrapper {lvalue})
*/


struct hbond_ideal_point_t_wrapper 
  : hbond_ideal_point_t, wrapper<hbond_ideal_point_t>
{
  hbond_ideal_point_t_wrapper(hbond_ideal_point_t const &arg)
    : hbond_ideal_point_t(arg), wrapper<hbond_ideal_point_t>(){
    // copy constructor
  }

  hbond_ideal_point_t_wrapper() 
    : hbond_ideal_point_t(), wrapper<hbond_ideal_point_t>(){
    // null constructor
  }

  const ASCbase::atom_t&
   __get_atom() const
   { return *atom; }

  const ASCbase::atom_t&
   __get_carbon_nbr() const
   { return *carbon_nbr; }
};

// Note one must be careful here since the point_t and additional machinery
// has a nonstandard allocation scheme so that the positions of atoms, etc
// can be stored in a contiguous hunk of memory to allow for rapid operations
// (i.e. transformation of coordinates).

// In particular one should not be creating hbond points or hbond ideal points
// in python but use the C++ extensions to do so
BOOST_PYTHON_MODULE(_hbond_points){
  enum_< ASCbase::interactionType>("interactionType")
    .value("UNKNOWN_INTERACTION", ASCbase::UNKNOWN_INTERACTION)
    .value("ACCEPTOR", ASCbase::ACCEPTOR)
    .value("DONOR", ASCbase::DONOR)
    .value("HYDROPHOB", ASCbase::HYDROPHOB)
    .value("DONEPTOR", ASCbase::DONEPTOR)
    .value("DONOR_HYDROGEN", ASCbase::DONOR_HYDROGEN)
    .value("METAL_1", ASCbase::METAL_1)
    .value("METAL_2", ASCbase::METAL_2)
    .value("HBVEC", ASCbase::HBVEC)
    .value("NOTHING", ASCbase::NOTHING)
    .export_values()
  ;
 
  { // dir_point_t
    typedef class_<dir_point_t_wrapper> dir_point_t_exposer_t;
    dir_point_t_exposer_t dir_point_exposer = 
      dir_point_t_exposer_t("dir_point_t");
    scope dir_point_t_scope(dir_point_exposer);

    pyplusplus::containers::static_sized::register_array_1<double, 3>
      ("__array_1_double_3");
    {  // ASCbase::dir_point_t::dir [variable], type = myfloat_t[3]
      typedef pyplusplus::containers::static_sized::array_1_t<double,3>
        (*array_wrapper_creator)(dir_point_t &);
      dir_point_exposer.add_property("dir",
        make_function(array_wrapper_creator(&dir_point_t_wrapper::pyplusplus_dir_wrapper), 
        with_custodian_and_ward_postcall<0,1>()) );
    }
  }
/*
  { // hbond_ideal_point_t
    class_<hbond_ideal_point_t, bases<dir_point_t, point_t> >
      ("__hbond_ideal_point")    
      .def_readwrite("pt_num", &hbond_ideal_point_t::pt_num)
      .def_readwrite("act_type", &hbond_ideal_point_t::act_type)
    ;
  }
*/
  
  // hbond_ideal_point_t_wrapper
  typedef class_<hbond_ideal_point_t_wrapper, 
                 bases<dir_point_t, point_t> > 
    hbond_ideal_pt_exposer_t;
  hbond_ideal_pt_exposer_t hbond_ideal_pt_exposer = 
    hbond_ideal_pt_exposer_t("hbond_ideal_point", init<>())
      .def_readwrite("pt_num", &hbond_ideal_point_t::pt_num)
      .def_readwrite("act_type", &hbond_ideal_point_t::act_type)
   //   .def("atom", &hbond_ideal_point_t_wrapper::__get_atom,
    //       return_internal_reference<1>())
    ;
  scope hbond_ideal_pt_exposer_t_scope(hbond_ideal_pt_exposer);
  hbond_ideal_pt_exposer.add_property("atom", &hbond_ideal_point_t_wrapper::__get_atom, return_value_policy<return_by_value>());

    //.def("atom", &hbond_ideal_point_t_wrapper::__get_atom,
     //    return_internal_reference<1>())
    //.def_readwrite("atom", &hbond_ideal_point_t::atom)
    //.def_readwrite("carbon_nbr", &hbond_ideal_point_t::carbon_nbr)
  ;
}
#endif
