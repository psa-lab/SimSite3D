<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>simsite3d: sphere.H Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>sphere.H</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#ifndef SPHERES_HEADER_FILE_INCLUDED</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor">#define SPHERES_HEADER_FILE_INCLUDED</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;string_basics.H&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;math_basics.H&gt;</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="keyword">namespace </span>ASCbase{
<a name="l00010"></a>00010 <span class="keyword">namespace </span>geometry{
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="keyword">class </span>sphere_t{
<a name="l00013"></a>00013 <span class="keyword">public</span>:
<a name="l00015"></a>00015   <span class="keyword">typedef</span> <span class="keyword">enum</span>{
<a name="l00016"></a>00016     NONE = 0,              
<a name="l00017"></a>00017     INTERSECTION,          
<a name="l00018"></a>00018     OTHER_CONTAINS_THIS,   
<a name="l00019"></a>00019     THIS_CONTAINS_OTHER    
<a name="l00020"></a>00020   }intersectionType;
<a name="l00021"></a>00021 
<a name="l00023"></a>00023   sphere_t()
<a name="l00024"></a>00024   { 
<a name="l00025"></a>00025     std::fill(A_center, A_center + 3, 0.0);
<a name="l00026"></a>00026     A_sq_rad = 0.0;
<a name="l00027"></a>00027     A_radius = -1.0;
<a name="l00028"></a>00028   }
<a name="l00029"></a>00029 
<a name="l00031"></a>00031   sphere_t(<span class="keyword">const</span> my_float_t* c, <span class="keyword">const</span> my_float_t r)
<a name="l00032"></a>00032   {
<a name="l00033"></a>00033     std::copy(c, c+3, A_center);
<a name="l00034"></a>00034     std::copy(c, c+3, A_orig_center);
<a name="l00035"></a>00035     A_radius = r;
<a name="l00036"></a>00036     A_sq_rad = A_radius * A_radius;
<a name="l00037"></a>00037   }
<a name="l00038"></a>00038 
<a name="l00040"></a>00040   sphere_t(<span class="keyword">const</span> sphere_t&amp; src)
<a name="l00041"></a>00041   {
<a name="l00042"></a>00042     do_copy(src);
<a name="l00043"></a>00043   }
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   <span class="keyword">const</span> sphere_t&amp;
<a name="l00046"></a>00046   operator=(<span class="keyword">const</span> sphere_t&amp; src)
<a name="l00047"></a>00047   {
<a name="l00048"></a>00048     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;src) do_copy(src);
<a name="l00049"></a>00049     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00050"></a>00050   }
<a name="l00051"></a>00051 
<a name="l00053"></a>00053   <span class="keyword">const</span> <span class="keywordtype">bool</span>
<a name="l00054"></a>00054   contains(<span class="keyword">const</span> my_float_t* pt)<span class="keyword"> const</span>
<a name="l00055"></a>00055 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (A_sq_rad &gt;= dist_squared(A_center, pt)); }
<a name="l00056"></a>00056 
<a name="l00058"></a>00058   <span class="keyword">const</span> my_float_t*
<a name="l00059"></a>00059   center()<span class="keyword"> const</span>
<a name="l00060"></a>00060 <span class="keyword">  </span>{ <span class="keywordflow">return</span> A_center; }
<a name="l00061"></a>00061 
<a name="l00063"></a>00063   <span class="keyword">const</span> my_float_t
<a name="l00064"></a>00064   radius()<span class="keyword"> const</span>
<a name="l00065"></a>00065 <span class="keyword">  </span>{ <span class="keywordflow">return</span> A_radius; }
<a name="l00066"></a>00066 
<a name="l00068"></a>00068   <span class="keyword">const</span> my_float_t
<a name="l00069"></a>00069   squared_radius()<span class="keyword"> const</span>
<a name="l00070"></a>00070 <span class="keyword">  </span>{ <span class="keywordflow">return</span> A_sq_rad; }
<a name="l00071"></a>00071 
<a name="l00073"></a>00073   <span class="keyword">const</span> <span class="keywordtype">bool</span>
<a name="l00074"></a>00074   operator==(<span class="keyword">const</span> sphere_t&amp; other)
<a name="l00075"></a>00075   {
<a name="l00076"></a>00076     <span class="keywordflow">if</span>(A_radius != other.A_radius) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00077"></a>00077     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) 
<a name="l00078"></a>00078       <span class="keywordflow">if</span>(A_center[i] != other.A_center[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00079"></a>00079     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00080"></a>00080   }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   <span class="keyword">friend</span> std::ostream&amp; 
<a name="l00083"></a>00083   operator&lt;&lt;(std::ostream &amp;out, <span class="keyword">const</span> sphere_t&amp; S)
<a name="l00084"></a>00084   { 
<a name="l00085"></a>00085     out &lt;&lt; S.A_center[0] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; S.A_center[1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; S.A_center[2] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00086"></a>00086         &lt;&lt; S.A_radius;
<a name="l00087"></a>00087     <span class="keywordflow">return</span> out;
<a name="l00088"></a>00088   }
<a name="l00089"></a>00089 
<a name="l00091"></a>00091   <span class="keywordtype">void</span>
<a name="l00092"></a>00092   project_point(<span class="keyword">const</span> my_float_t* pt, my_float_t* proj_pt)<span class="keyword"> const</span>
<a name="l00093"></a>00093 <span class="keyword">  </span>{
<a name="l00094"></a>00094     my_float_t V[3];
<a name="l00095"></a>00095     unit_vector(V, pt, A_center);
<a name="l00096"></a>00096     std::copy(A_center, A_center + 3, proj_pt);
<a name="l00097"></a>00097     my_axpy(3, A_radius, V, 1, proj_pt, 1);
<a name="l00098"></a>00098   }
<a name="l00099"></a>00099 
<a name="l00101"></a>00101 
<a name="l00105"></a>00105   <span class="keywordtype">int</span>
<a name="l00106"></a>00106   intersection(<span class="keyword">const</span> my_float_t* m, <span class="keyword">const</span> my_float_t* b,
<a name="l00107"></a>00107                my_float_t* pts)
<a name="l00108"></a>00108   {
<a name="l00109"></a>00109     <span class="comment">// Get vector from point on line (intercept) to the center of the sphere</span>
<a name="l00110"></a>00110     my_float_t b2center[3];
<a name="l00111"></a>00111     std::copy(A_center, A_center + 3, b2center);
<a name="l00112"></a>00112     my_axpy(3, -1.0, b, 1, b2center, 1); 
<a name="l00113"></a>00113 
<a name="l00114"></a>00114     <span class="comment">// Project bc onto m</span>
<a name="l00115"></a>00115     my_float_t proj_len = dot(m, b2center);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     <span class="comment">// Computpe the squared distance from the center of the circle to the line</span>
<a name="l00118"></a>00118     my_float_t b2center_sq_len = dot(b2center, b2center);
<a name="l00119"></a>00119     my_float_t h2 = b2center_sq_len - proj_len*proj_len;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="comment">// Line lies outside of sphere</span>
<a name="l00122"></a>00122     <span class="keywordflow">if</span>(h2 &gt;= A_sq_rad) <span class="keywordflow">return</span> 0;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     <span class="comment">// We know the radius and the "height" of the triangle, get the length of</span>
<a name="l00125"></a>00125     <span class="comment">// the side of the triangle that is lying on the line y = mx + b</span>
<a name="l00126"></a>00126     my_float_t d = std::sqrt(A_sq_rad - h2);
<a name="l00127"></a>00127     std::copy(b, b+3, pts);
<a name="l00128"></a>00128     my_axpy(3, proj_len, m, 1, pts, 1);
<a name="l00129"></a>00129 <span class="comment">// Need to determine how to correctly check since eps isn't always the right</span>
<a name="l00130"></a>00130 <span class="comment">// threshold</span>
<a name="l00131"></a>00131     <span class="comment">//if(-1.0*my_float_eps &lt; d &amp;&amp; d &lt; my_float_eps) return 1;</span>
<a name="l00132"></a>00132     std::copy(pts, pts+3, pts+3);
<a name="l00133"></a>00133     my_axpy(3, -1.0*d, m, 1, pts, 1);
<a name="l00134"></a>00134     my_axpy(3, d, m, 1, pts+3, 1);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keywordflow">return</span> 2;
<a name="l00137"></a>00137   }
<a name="l00138"></a>00138 
<a name="l00141"></a>00141   intersectionType
<a name="l00142"></a>00142   intersects(<span class="keyword">const</span> sphere_t&amp; other, my_float_t *vol)<span class="keyword"> const</span>
<a name="l00143"></a>00143 <span class="keyword">  </span>{
<a name="l00144"></a>00144     <span class="comment">// Check if the two spheres intersect -- assume intersection at a point</span>
<a name="l00145"></a>00145     <span class="comment">// is not a significant intersection </span>
<a name="l00146"></a>00146     my_float_t D2 = dist_squared(A_center, other.A_center);
<a name="l00147"></a>00147     <span class="keywordflow">if</span>(D2 &gt;= (A_radius + other.A_radius)*(A_radius + other.A_radius))
<a name="l00148"></a>00148       <span class="keywordflow">return</span> NONE;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="comment">// Check if this sphere contains the other one</span>
<a name="l00151"></a>00151     <span class="keywordflow">if</span>(contains(other)){
<a name="l00152"></a>00152       *vol = 4.0/3.0 * M_PI * other.A_radius*other.A_radius*other.A_radius;
<a name="l00153"></a>00153       <span class="keywordflow">return</span> THIS_CONTAINS_OTHER;
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155     <span class="keywordflow">if</span>(other.contains(*<span class="keyword">this</span>)){
<a name="l00156"></a>00156       *vol = 4.0/3.0 * M_PI * A_radius*A_radius*A_radius;
<a name="l00157"></a>00157       <span class="keywordflow">return</span> OTHER_CONTAINS_THIS;
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159 
<a name="l00161"></a>00161     <span class="comment">// Determine the volume of this sphere's cap inside the other</span>
<a name="l00162"></a>00162     <span class="comment">// V_cap = 1/3 pi h^2 (3R - h) -- mathworld.wolfram.com/SphericalCap.html</span>
<a name="l00164"></a>00164 <span class="comment"></span>
<a name="l00165"></a>00165     <span class="comment">// What is the height of the cap? -- use law of cosines + algebra</span>
<a name="l00166"></a>00166     my_float_t h;
<a name="l00167"></a>00167     <span class="keywordflow">if</span>(A_radius &gt;= other.A_radius){
<a name="l00168"></a>00168       <span class="keywordflow">if</span>(contains(other.A_center)){
<a name="l00169"></a>00169         my_float_t d = -A_radius * (other.A_radius*other.A_radius - A_radius*A_radius - D2) / (-2.0 * A_radius * std::sqrt(D2));
<a name="l00170"></a>00170         h = A_radius - d;
<a name="l00171"></a>00171        
<a name="l00172"></a>00172         <span class="comment">// Here h is the height of the cap of the smaller sphere that lies</span>
<a name="l00173"></a>00173         <span class="comment">// outside of the larger sphere (here the other sphere has the smaller</span>
<a name="l00174"></a>00174         <span class="comment">// radius</span>
<a name="l00175"></a>00175         *vol = -1.0 * (1.0/3.0 * M_PI * h*h * (3*other.A_radius - h));
<a name="l00176"></a>00176         *vol += 4.0/3.0 * M_PI * other.A_radius*other.A_radius*other.A_radius;
<a name="l00177"></a>00177         
<a name="l00178"></a>00178       }<span class="keywordflow">else</span>{
<a name="l00179"></a>00179         <span class="comment">// d is the portion of the radius of this sphere that is out side of</span>
<a name="l00180"></a>00180         <span class="comment">// the other sphere</span>
<a name="l00181"></a>00181         my_float_t d = 0.5 * ((D2 + A_radius*A_radius - 
<a name="l00182"></a>00182                                other.A_radius*other.A_radius) / std::sqrt(D2));
<a name="l00183"></a>00183         h = A_radius - d;
<a name="l00184"></a>00184         *vol = 1.0/3.0 * M_PI * h*h * (3*A_radius - h);
<a name="l00185"></a>00185       }
<a name="l00186"></a>00186     }<span class="keywordflow">else</span>{
<a name="l00187"></a>00187       <span class="keywordflow">if</span>(other.contains(A_center)){
<a name="l00188"></a>00188         my_float_t d = -A_radius * (other.A_radius*other.A_radius - A_radius*A_radius - D2) / (-2.0 * A_radius * std::sqrt(D2));
<a name="l00189"></a>00189         h = A_radius - d;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <span class="comment">// Here h is the height of the cap of the smaller sphere that lies</span>
<a name="l00192"></a>00192         <span class="comment">// outside of the larger sphere (here this sphere has the smaller</span>
<a name="l00193"></a>00193         <span class="comment">// radius</span>
<a name="l00194"></a>00194         *vol = -1.0 * (1.0/3.0 * M_PI * h*h * (3*A_radius - h));
<a name="l00195"></a>00195         *vol += 4.0/3.0 * M_PI * A_radius*A_radius*A_radius;
<a name="l00196"></a>00196         
<a name="l00197"></a>00197       }<span class="keywordflow">else</span>{
<a name="l00198"></a>00198         <span class="comment">// d is the portion of the radius of this sphere that is out side of</span>
<a name="l00199"></a>00199         <span class="comment">// the other sphere</span>
<a name="l00200"></a>00200         my_float_t d = 0.5 * ((D2 + A_radius*A_radius - 
<a name="l00201"></a>00201                                other.A_radius*other.A_radius) / std::sqrt(D2));
<a name="l00202"></a>00202         h = A_radius - d;
<a name="l00203"></a>00203         *vol = 1.0/3.0 * M_PI * h*h * (3*A_radius - h);
<a name="l00204"></a>00204       } 
<a name="l00205"></a>00205     }
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <span class="keywordflow">return</span> INTERSECTION; 
<a name="l00208"></a>00208   }
<a name="l00209"></a>00209 
<a name="l00211"></a>00211   <span class="keywordtype">bool</span>
<a name="l00212"></a>00212   contains(<span class="keyword">const</span> sphere_t&amp; other)<span class="keyword"> const</span>
<a name="l00213"></a>00213 <span class="keyword">  </span>{
<a name="l00214"></a>00214     <span class="keywordflow">if</span>(!contains(other.A_center)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="comment">// Get a unit vector from this sphere's center in the direction of the</span>
<a name="l00217"></a>00217     <span class="comment">// other spheres's center</span>
<a name="l00218"></a>00218     my_float_t V[3];
<a name="l00219"></a>00219     unit_vector(V, other.A_center, A_center); 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     <span class="comment">// Project from the center of the other sphere along the unit vector's </span>
<a name="l00222"></a>00222     <span class="comment">// direction</span>
<a name="l00223"></a>00223     my_float_t proj_pt[3];
<a name="l00224"></a>00224     std::copy(other.A_center, other.A_center + 3, proj_pt);
<a name="l00225"></a>00225     my_axpy(3, other.A_radius, V, 1, proj_pt, 1);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="comment">// If that point is inside this sphere, then it is contained in</span>
<a name="l00228"></a>00228     <span class="comment">// this one</span>
<a name="l00229"></a>00229     <span class="keywordflow">return</span> contains(proj_pt); 
<a name="l00230"></a>00230   }
<a name="l00231"></a>00231 
<a name="l00233"></a>00233   <span class="keywordtype">void</span>
<a name="l00234"></a>00234   transform(<span class="keyword">const</span> my_float_t* R, <span class="keyword">const</span> my_float_t* T)
<a name="l00235"></a>00235   { 
<a name="l00236"></a>00236     my_float_t scratch[3];
<a name="l00237"></a>00237     std::copy(A_center, A_center + 3, scratch);
<a name="l00238"></a>00238     std::copy(T, T + 3, A_center);
<a name="l00239"></a>00239     my_gemm(1, 3, 3, 1.0, scratch, 1, R, 3, A_center, 1, 1.0);
<a name="l00240"></a>00240   }
<a name="l00241"></a>00241   
<a name="l00243"></a>00243   <span class="keywordtype">void</span>
<a name="l00244"></a>00244   inverse_transform(<span class="keyword">const</span> my_float_t* R, <span class="keyword">const</span> my_float_t* T)
<a name="l00245"></a>00245   { 
<a name="l00246"></a>00246     my_float_t scratch[3];
<a name="l00247"></a>00247     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) scratch[i] = A_center[i] - T[i];
<a name="l00248"></a>00248     my_gemm(3, 1, 3, 1.0, R, 3, scratch, 1, A_center, 1, 0.0);
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250   
<a name="l00252"></a>00252   <span class="keywordtype">void</span>
<a name="l00253"></a>00253   revert()
<a name="l00254"></a>00254   { std::copy(A_orig_center, A_orig_center + 3, A_center); }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="keyword">private</span>:
<a name="l00257"></a>00257   <span class="keywordtype">void</span>
<a name="l00258"></a>00258   do_copy(<span class="keyword">const</span> sphere_t&amp; src)
<a name="l00259"></a>00259   {
<a name="l00260"></a>00260     std::copy(src.A_center, src.A_center + 3, A_center);
<a name="l00261"></a>00261     std::copy(src.A_orig_center, src.A_orig_center + 3, A_orig_center);
<a name="l00262"></a>00262     A_radius = src.A_radius;
<a name="l00263"></a>00263     A_sq_rad = src.A_sq_rad;
<a name="l00264"></a>00264   }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   my_float_t A_radius;     
<a name="l00267"></a>00267   my_float_t A_sq_rad;     
<a name="l00268"></a>00268   my_float_t A_center[3];  
<a name="l00269"></a>00269   my_float_t A_orig_center[3]; 
<a name="l00270"></a>00270 };
<a name="l00271"></a>00271 
<a name="l00273"></a><a class="code" href="classASCbase_1_1geometry_1_1plane__t.html">00273</a> <span class="keyword">class </span><a class="code" href="classASCbase_1_1geometry_1_1plane__t.html">plane_t</a>{
<a name="l00274"></a>00274 <span class="keyword">public</span>:
<a name="l00276"></a><a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">00276</a>   <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>()
<a name="l00277"></a>00277   { 
<a name="l00278"></a>00278     std::fill(<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a> + 3, 0.0);
<a name="l00279"></a>00279     std::fill(<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">A_P0</a>, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">A_P0</a> + 3, 0.0);
<a name="l00280"></a>00280     A_P0_is_defined = <span class="keyword">false</span>;
<a name="l00281"></a>00281     <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">A_d</a> = 0.0;
<a name="l00282"></a>00282   }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>(<span class="keyword">const</span> my_float_t* N, <span class="keyword">const</span> my_float_t *P0)
<a name="l00285"></a>00285   {
<a name="l00286"></a>00286     std::copy(N, N+3, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>);
<a name="l00287"></a>00287     std::copy(P0, P0 + 3, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">A_P0</a>);
<a name="l00288"></a>00288     A_P0_is_defined = <span class="keyword">true</span>;
<a name="l00289"></a>00289     <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">A_d</a> = -1.0 * dot(N, P0);
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>(<span class="keyword">const</span> my_float_t* N, <span class="keyword">const</span> my_float_t d)
<a name="l00293"></a>00293   {
<a name="l00294"></a>00294     std::copy(N, N+3, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>);
<a name="l00295"></a>00295     <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">A_d</a> = d;
<a name="l00296"></a>00296     A_P0_is_defined = <span class="keyword">false</span>;
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>&amp; src)
<a name="l00300"></a>00300   {
<a name="l00301"></a>00301     do_copy(src);
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>&amp;
<a name="l00305"></a>00305   operator=(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>&amp; src)
<a name="l00306"></a>00306   {
<a name="l00307"></a>00307     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;src) do_copy(src);
<a name="l00308"></a>00308     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   ~<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>()
<a name="l00312"></a>00312   { ; }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   my_float_t 
<a name="l00315"></a>00315   signed_dist(<span class="keyword">const</span> my_float_t* pt)<span class="keyword"> const </span>
<a name="l00316"></a>00316 <span class="keyword">  </span>{
<a name="l00317"></a>00317     <span class="keywordflow">if</span>(!A_P0_is_defined){
<a name="l00318"></a>00318       printf(<span class="stringliteral">"ERROR, P0 is not defined (in signed_dist)!!!!!!!!!!!!\n"</span>);
<a name="l00319"></a>00319       <span class="comment">//A_P0[2] = 0.0;</span>
<a name="l00320"></a>00320        
<a name="l00321"></a>00321     }
<a name="l00322"></a>00322     my_float_t V[3];
<a name="l00323"></a>00323     vector(3, pt, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">A_P0</a>, V);
<a name="l00324"></a>00324     <span class="keywordflow">return</span> dot(V, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>);
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326 
<a name="l00328"></a>00328 
<a name="l00331"></a>00331   <span class="keywordtype">void</span>
<a name="l00332"></a><a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#aad5de4249d5e30464f69e0280f62fd3">00332</a>   <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#aad5de4249d5e30464f69e0280f62fd3">intersection</a>(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html">plane_t</a>&amp; other, my_float_t* m, my_float_t* b)
<a name="l00333"></a>00333   {
<a name="l00334"></a>00334     cross(<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>, other.<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>, m);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     <span class="comment">// Determine the component of m with the largest magnitude</span>
<a name="l00337"></a>00337     my_float_t n = 0.0;
<a name="l00338"></a>00338     <span class="keywordtype">int</span> idx = argmaxabs&lt;my_float_t&gt;(m, 3, &amp;n);
<a name="l00339"></a>00339 
<a name="l00340"></a>00340     <span class="comment">// Solve the reduced system (ignore the coordinate with the largest normal</span>
<a name="l00341"></a>00341     <span class="comment">// component)</span>
<a name="l00342"></a>00342     my_float_t A[4];
<a name="l00343"></a>00343     my_float_t *a = A;
<a name="l00344"></a>00344     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i){
<a name="l00345"></a>00345       <span class="keywordflow">if</span>(i == idx) b[i] = 0.0;
<a name="l00346"></a>00346       <span class="keywordflow">else</span>{
<a name="l00347"></a>00347         *a = <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>[i];
<a name="l00348"></a>00348         *(a+2) = other.<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>[i];
<a name="l00349"></a>00349         ++a;
<a name="l00350"></a>00350       }
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     a = 0;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     my_float_t det_A = A[0]*A[3] - A[2]*A[1];
<a name="l00355"></a>00355     my_float_t A_inv[] = {A[3] / det_A,      -1.0*A[1] / det_A,
<a name="l00356"></a>00356                           -1.0*A[2] / det_A, A[0] / det_A      };
<a name="l00357"></a>00357     a = A_inv;
<a name="l00358"></a>00358     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i, ++b){
<a name="l00359"></a>00359       <span class="keywordflow">if</span>(i == idx) <span class="keywordflow">continue</span>;
<a name="l00360"></a>00360       *b = -1.0 * ((*a) * <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">A_d</a> + (*(a+1)) * other.<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">A_d</a>);
<a name="l00361"></a>00361       a += 2;
<a name="l00362"></a>00362     }
<a name="l00363"></a>00363   }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="keyword">const</span> my_float_t*
<a name="l00366"></a>00366   normal()<span class="keyword"> const</span>
<a name="l00367"></a>00367 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>; }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369   <span class="keyword">const</span> my_float_t*
<a name="l00370"></a>00370   point()<span class="keyword"> const</span>
<a name="l00371"></a>00371 <span class="keyword">  </span>{ 
<a name="l00372"></a>00372     <span class="keywordflow">if</span>(!A_P0_is_defined){
<a name="l00373"></a>00373       printf(<span class="stringliteral">"ERROR, P0 is not defined (in point)!!!!!!!!!!!!\n"</span>);
<a name="l00374"></a>00374       <span class="keywordflow">return</span> 0;
<a name="l00375"></a>00375     }
<a name="l00376"></a>00376     <span class="keywordflow">return</span> <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">A_P0</a>; 
<a name="l00377"></a>00377   }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="keyword">private</span>:
<a name="l00380"></a>00380   <span class="keywordtype">void</span>
<a name="l00381"></a>00381   do_copy(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#6a96b14a51383e4f04b440fa4f89ce72">plane_t</a>&amp; src)
<a name="l00382"></a>00382   {
<a name="l00383"></a>00383     std::copy(src.A_N, src.A_N + 3, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>);
<a name="l00384"></a>00384     std::copy(src.A_P0, src.A_P0 + 3, <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">A_P0</a>);
<a name="l00385"></a>00385     <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">A_d</a> = src.A_d;
<a name="l00386"></a>00386     A_P0_is_defined = src.A_P0_is_defined;
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 
<a name="l00389"></a><a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">00389</a>   my_float_t <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#729fc8d83f6730ffccbf6ebfddaf8f77">A_N</a>[3];   
<a name="l00390"></a><a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">00390</a>   my_float_t <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#9b2e543bd396510e30f8c38b95c13b43">A_P0</a>[3];    
<a name="l00391"></a><a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">00391</a>   my_float_t <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d8acc9a64d3c29dd0f25e9a681dcb343">A_d</a>;        
<a name="l00392"></a>00392   <span class="keywordtype">bool</span> A_P0_is_defined;
<a name="l00393"></a>00393 };
<a name="l00394"></a>00394 
<a name="l00396"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">00396</a> <span class="keyword">class </span><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>{
<a name="l00397"></a>00397 <span class="keyword">public</span>:
<a name="l00398"></a>00398 
<a name="l00400"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#fd9cea33957ae88b1f380bf809cbbff6">00400</a>   <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#fd9cea33957ae88b1f380bf809cbbff6">arc_t</a>(<span class="keyword">const</span> sphere_t&amp; S, <span class="keyword">const</span> my_float_t* end_pt0, <span class="keyword">const</span> my_float_t* mid_pt,
<a name="l00401"></a>00401         <span class="keyword">const</span> my_float_t* end_pt1) : <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>(S)
<a name="l00402"></a>00402   {
<a name="l00403"></a>00403     <span class="comment">//A_S = S;</span>
<a name="l00404"></a>00404     std::copy(end_pt0, end_pt0 + 3, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>);
<a name="l00405"></a>00405     std::copy(end_pt1, end_pt1 + 3, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407     std::copy(mid_pt, mid_pt + 3, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#abb892372174ae16d4485cd46ceb5aac">A_mid_pt</a>);
<a name="l00408"></a>00408     unit_vector(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#a945c545c3b2ac14757f8cc6bf9326df">A_in_dir</a>, mid_pt, S.center());
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     mid_point(end_pt0, end_pt1, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#e5da612f0b29559898b76854005028f7">A_chord_mid_pt</a>);
<a name="l00411"></a>00411   }
<a name="l00412"></a>00412 
<a name="l00414"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#18b1410a465b4add59d54d8654bf8842">00414</a>   <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#fd9cea33957ae88b1f380bf809cbbff6">arc_t</a>(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>&amp; src) : <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>(src.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>)
<a name="l00415"></a>00415   {
<a name="l00416"></a>00416     do_copy(src);
<a name="l00417"></a>00417   }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419   <span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>&amp;
<a name="l00420"></a>00420   operator=(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>&amp; src)
<a name="l00421"></a>00421   {
<a name="l00422"></a>00422     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;src){
<a name="l00423"></a>00423       do_copy(src);
<a name="l00424"></a>00424       <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a> = src.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>;
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00427"></a>00427   }
<a name="l00428"></a>00428 
<a name="l00430"></a>00430   <span class="keyword">const</span> <span class="keywordtype">bool</span>
<a name="l00431"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#01ba159b58239264350e90caa746dca7">00431</a>   <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#01ba159b58239264350e90caa746dca7">contains</a>(<span class="keyword">const</span> my_float_t* pt)<span class="keyword"> const</span>
<a name="l00432"></a>00432 <span class="keyword">  </span>{
<a name="l00433"></a>00433     my_float_t my_dir[3];
<a name="l00434"></a>00434     std::copy(pt, pt + 3, my_dir);
<a name="l00435"></a>00435     my_axpy(3, -1.0, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#e5da612f0b29559898b76854005028f7">A_chord_mid_pt</a>, 1, my_dir, 1);
<a name="l00436"></a>00436     <span class="keywordflow">if</span>(dot(my_dir, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#a945c545c3b2ac14757f8cc6bf9326df">A_in_dir</a>) &gt;= 0.0) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00437"></a>00437     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00438"></a>00438   }
<a name="l00439"></a>00439 
<a name="l00442"></a>00442 
<a name="l00445"></a>00445   <span class="keywordtype">void</span>
<a name="l00446"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#05ed53967368242ccad327e056f1d897">00446</a>   <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#05ed53967368242ccad327e056f1d897">intersection</a>(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>&amp; other, std::vector&lt;arc_t&gt;* I_arcs)
<a name="l00447"></a>00447   {
<a name="l00448"></a>00448     std::vector&lt;bool&gt; self_contains_other_pts, other_contains_self_pts;
<a name="l00449"></a>00449     self_contains_other_pts.push_back(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#01ba159b58239264350e90caa746dca7">contains</a>(other.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>));
<a name="l00450"></a>00450     self_contains_other_pts.push_back(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#01ba159b58239264350e90caa746dca7">contains</a>(other.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3));
<a name="l00451"></a>00451     other_contains_self_pts.push_back(other.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#01ba159b58239264350e90caa746dca7">contains</a>(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>));
<a name="l00452"></a>00452     other_contains_self_pts.push_back(other.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#01ba159b58239264350e90caa746dca7">contains</a>(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3));
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     <span class="comment">// Case 1) Other arc is contained in self -- intersection is other_arc</span>
<a name="l00455"></a>00455     <span class="keywordflow">if</span>(self_contains_other_pts[0] &amp;&amp; self_contains_other_pts[1] &amp;&amp;
<a name="l00456"></a>00456        !other_contains_self_pts[0] &amp;&amp; !other_contains_self_pts[1])
<a name="l00457"></a>00457       I_arcs-&gt;push_back(other);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459     <span class="comment">// Case 2) Other arc contains self -- intersection is self</span>
<a name="l00460"></a>00460     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(other_contains_self_pts[0] &amp;&amp; other_contains_self_pts[1] &amp;&amp;
<a name="l00461"></a>00461             !self_contains_other_pts[0] &amp;&amp; !self_contains_other_pts[1])
<a name="l00462"></a>00462       I_arcs-&gt;push_back(*<span class="keyword">this</span>);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     <span class="comment">// Case 3) Other arc has no overlap with self -- no intersection</span>
<a name="l00465"></a>00465     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!self_contains_other_pts[0] &amp;&amp; !self_contains_other_pts[1] &amp;&amp;
<a name="l00466"></a>00466             !other_contains_self_pts[0] &amp;&amp; !other_contains_self_pts[1]);
<a name="l00467"></a>00467       <span class="comment">// Pass as there is no intersection</span>
<a name="l00468"></a>00468 
<a name="l00469"></a>00469     <span class="comment">// Case 4) Other arc partially overlaps self -- intersection is the overlap</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     <span class="comment">// Case 4a) all points from each arc are contained in the other arc</span>
<a name="l00472"></a>00472     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(self_contains_other_pts[0] &amp;&amp; self_contains_other_pts[1] &amp;&amp;
<a name="l00473"></a>00473             other_contains_self_pts[0] &amp;&amp; other_contains_self_pts[1]){
<a name="l00474"></a>00474 
<a name="l00475"></a>00475       <span class="comment">// idea -- move the chord for self along the in direction until</span>
<a name="l00476"></a>00476       <span class="comment">// we reach an endpoint of the other arc (i.e. y = mx + b)</span>
<a name="l00477"></a>00477       my_float_t sq_dists[4];
<a name="l00478"></a>00478       sq_dists[0] = dist_squared(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>, other.A_end_pts);
<a name="l00479"></a>00479       sq_dists[1] = dist_squared(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>, other.A_end_pts + 3);
<a name="l00480"></a>00480       sq_dists[2] = dist_squared(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3, other.A_end_pts);
<a name="l00481"></a>00481       sq_dists[3] = dist_squared(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3, other.A_end_pts + 3);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483       my_float_t tmp;
<a name="l00484"></a>00484       <span class="keywordtype">int</span> idx = argmin(sq_dists, 4, &amp;tmp);
<a name="l00485"></a>00485       <span class="keywordtype">int</span> self_idx = static_cast&lt;int&gt;(std::floor(idx / 2.0));
<a name="l00486"></a>00486       <span class="keywordtype">int</span> other_idx = idx % 2;
<a name="l00487"></a>00487 
<a name="l00488"></a>00488       <span class="comment">// Because we are taking the two closest points (1 end point from each</span>
<a name="l00489"></a>00489       <span class="comment">// arc), we know that the in direction is the vector from the center of</span>
<a name="l00490"></a>00490       <span class="comment">// the circle to midpoint of the corresponding chord</span>
<a name="l00491"></a>00491       my_float_t my_dir[3];
<a name="l00492"></a>00492       compute_overlap(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3*self_idx, other.A_end_pts + 3*other_idx,
<a name="l00493"></a>00493                       I_arcs, my_dir);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495       <span class="comment">// Next, we use the other 2 points do define another chord and compute</span>
<a name="l00496"></a>00496       <span class="comment">// the direction from the center to the midpoint of the chord.</span>
<a name="l00497"></a>00497       <span class="keywordtype">int</span> A1_self_idx = (self_idx + 1) % 2; 
<a name="l00498"></a>00498       <span class="keywordtype">int</span> A1_other_idx = (other_idx + 1) % 2; 
<a name="l00499"></a>00499       uint my_len = I_arcs-&gt;size();
<a name="l00500"></a>00500       compute_overlap(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3*A1_self_idx, 
<a name="l00501"></a>00501                       other.A_end_pts + 3*A1_other_idx, I_arcs, my_dir);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503       <span class="comment">// If the second arc contains one of the end points of other_arc, we need </span>
<a name="l00504"></a>00504       <span class="comment">// to flip the direction.</span>
<a name="l00505"></a>00505       <span class="keywordflow">if</span>(I_arcs-&gt;size() &gt; my_len){
<a name="l00506"></a>00506         <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>&amp; A1 = I_arcs-&gt;back();
<a name="l00507"></a>00507         <span class="keywordflow">if</span>(A1.contains(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a> + 3*self_idx) || 
<a name="l00508"></a>00508            A1.contains(other.A_end_pts + 3*other_idx)){
<a name="l00509"></a>00509           std::copy(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.center(), <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.center() + 3, A1.A_mid_pt);
<a name="l00510"></a>00510           my_axpy(3, -1.0 * <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.radius(), my_dir, 1, A1.A_mid_pt, 1);
<a name="l00511"></a>00511         }
<a name="l00512"></a>00512       }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514     <span class="comment">// Case 4b) One point from each arc is contained in the other arc</span>
<a name="l00515"></a>00515     }<span class="keywordflow">else</span>{
<a name="l00516"></a>00516       my_float_t my_end_pts[6];
<a name="l00517"></a>00517       <span class="keywordflow">if</span>(self_contains_other_pts[0])
<a name="l00518"></a>00518         std::copy(other.A_end_pts, other.A_end_pts + 3, my_end_pts);
<a name="l00519"></a>00519       <span class="keywordflow">else</span>
<a name="l00520"></a>00520         std::copy(other.A_end_pts + 3, other.A_end_pts + 6, my_end_pts);
<a name="l00521"></a>00521       <span class="keywordflow">if</span>(other_contains_self_pts[0])
<a name="l00522"></a>00522         std::copy(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>, A_end_pts + 3, my_end_pts + 3);
<a name="l00523"></a>00523       <span class="keywordflow">else</span>
<a name="l00524"></a>00524         std::copy(A_end_pts + 3, A_end_pts + 6, my_end_pts + 3);
<a name="l00525"></a>00525       
<a name="l00526"></a>00526       <span class="comment">// We will ignore very small arcs or those that are computed to be</span>
<a name="l00527"></a>00527       <span class="comment">// a point </span>
<a name="l00528"></a>00528       <span class="keywordflow">if</span>(dist_squared(my_end_pts, my_end_pts + 3) &lt; my_float_eps) <span class="keywordflow">return</span>;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530       my_float_t mid_pt[3], my_dir[3];
<a name="l00531"></a>00531       <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#bf87d7083d0b036b8aa49a8f76091462">arc_mid_point</a>(my_end_pts, my_end_pts + 3, mid_pt, my_dir);
<a name="l00532"></a>00532       <span class="keywordflow">if</span>(!<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#01ba159b58239264350e90caa746dca7">contains</a>(mid_pt) || !other.contains(mid_pt)){
<a name="l00533"></a>00533         std::copy(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.center(), <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.center() + 3, mid_pt);
<a name="l00534"></a>00534          my_axpy(3, -1.0 * <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.radius(), my_dir, 1, mid_pt, 1);
<a name="l00535"></a>00535       }
<a name="l00536"></a>00536       
<a name="l00537"></a>00537       I_arcs-&gt;push_back(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#fd9cea33957ae88b1f380bf809cbbff6">arc_t</a>(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>, my_end_pts, mid_pt, my_end_pts + 3));
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539   }
<a name="l00540"></a>00540   
<a name="l00541"></a>00541   <span class="keyword">const</span> <span class="keywordtype">bool</span>
<a name="l00542"></a>00542   operator==(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>&amp; other)
<a name="l00543"></a>00543   {
<a name="l00544"></a>00544     <span class="keywordflow">if</span>(!(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a> == other.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00545"></a>00545     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)
<a name="l00546"></a>00546       <span class="keywordflow">if</span>(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>[i] != other.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00547"></a>00547     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)
<a name="l00548"></a>00548       <span class="keywordflow">if</span>(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#abb892372174ae16d4485cd46ceb5aac">A_mid_pt</a>[i] != other.<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#abb892372174ae16d4485cd46ceb5aac">A_mid_pt</a>[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00549"></a>00549     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00550"></a>00550   }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   <span class="keyword">friend</span> std::ostream&amp; 
<a name="l00553"></a>00553   operator&lt;&lt;(std::ostream &amp;out, <span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#fd9cea33957ae88b1f380bf809cbbff6">arc_t</a>&amp; A)
<a name="l00554"></a>00554   { 
<a name="l00555"></a>00555     out &lt;&lt; A.A_S &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l00556"></a>00556         &lt;&lt; A.A_end_pts[0] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; A.A_end_pts[1] &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l00557"></a>00557         &lt;&lt; A.A_end_pts[2] &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l00558"></a>00558         &lt;&lt; A.A_mid_pt[0] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; A.A_mid_pt[1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; A.A_mid_pt[2] &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l00559"></a>00559         &lt;&lt; A.A_end_pts[4] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; A.A_end_pts[5] &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l00560"></a>00560         &lt;&lt; A.A_end_pts[6];
<a name="l00561"></a>00561     <span class="keywordflow">return</span> out;
<a name="l00562"></a>00562   }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564   <span class="keyword">const</span> my_float_t*
<a name="l00565"></a>00565   end_pts()<span class="keyword"> const</span>
<a name="l00566"></a>00566 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>; }
<a name="l00567"></a>00567 
<a name="l00570"></a>00570   <span class="keyword">const</span> my_float_t*
<a name="l00571"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#86f92d310b8cc785ae09c45201f97258">00571</a>   <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#86f92d310b8cc785ae09c45201f97258">get_mid_pt</a>()<span class="keyword"> const</span>
<a name="l00572"></a>00572 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#abb892372174ae16d4485cd46ceb5aac">A_mid_pt</a>; }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="keyword">const</span> my_float_t*
<a name="l00575"></a>00575   in_dir()<span class="keyword"> const</span>
<a name="l00576"></a>00576 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#a945c545c3b2ac14757f8cc6bf9326df">A_in_dir</a>; }
<a name="l00577"></a>00577   
<a name="l00578"></a>00578 <span class="keyword">private</span>:
<a name="l00579"></a>00579 
<a name="l00581"></a>00581   <span class="keywordtype">void</span>
<a name="l00582"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#bf87d7083d0b036b8aa49a8f76091462">00582</a>   <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#bf87d7083d0b036b8aa49a8f76091462">arc_mid_point</a>(<span class="keyword">const</span> my_float_t* end_pt0, <span class="keyword">const</span> my_float_t* end_pt1,
<a name="l00583"></a>00583                 my_float_t* mid_pt, my_float_t* mid_pt_dir)
<a name="l00584"></a>00584   {
<a name="l00585"></a>00585     <span class="comment">// Compute the midpoint of the chord</span>
<a name="l00586"></a>00586     mid_point(end_pt0, end_pt1, mid_pt);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588     <span class="comment">// Find the unit vector in the direction from the center to the chord</span>
<a name="l00589"></a>00589     <span class="comment">// mid point</span>
<a name="l00590"></a>00590     unit_vector(mid_pt_dir, mid_pt, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.center());
<a name="l00591"></a>00591 
<a name="l00592"></a>00592     <span class="comment">// Compute the arc mid point by pushing the center of the circle out</span>
<a name="l00593"></a>00593     <span class="comment">// along the unit vector by a distance of the radius</span>
<a name="l00594"></a>00594     std::copy(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.center(), <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.center() + 3, mid_pt);
<a name="l00595"></a>00595     my_axpy(3, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>.radius(), mid_pt_dir, 1, mid_pt, 1);
<a name="l00596"></a>00596   }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   <span class="keywordtype">void</span> 
<a name="l00599"></a>00599   compute_overlap(<span class="keyword">const</span> my_float_t* self_end_pt, <span class="keyword">const</span> my_float_t* other_end_pt,
<a name="l00600"></a>00600                   std::vector&lt;arc_t&gt;* I_arcs, my_float_t* my_dir)
<a name="l00601"></a>00601   {
<a name="l00602"></a>00602       my_float_t mid_pt[3];
<a name="l00603"></a>00603       <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#bf87d7083d0b036b8aa49a8f76091462">arc_mid_point</a>(self_end_pt, other_end_pt, mid_pt, my_dir);
<a name="l00604"></a>00604       <span class="keywordflow">if</span>(dist_squared(self_end_pt, other_end_pt) &gt;= my_float_eps)
<a name="l00605"></a>00605         I_arcs-&gt;push_back(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#fd9cea33957ae88b1f380bf809cbbff6">arc_t</a>(<a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>, self_end_pt, mid_pt, other_end_pt));
<a name="l00606"></a>00606   }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   <span class="keywordtype">void</span> do_copy(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#fd9cea33957ae88b1f380bf809cbbff6">arc_t</a>&amp; src)
<a name="l00609"></a>00609   {
<a name="l00610"></a>00610     std::copy(src.A_end_pts, src.A_end_pts + 6, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>);
<a name="l00611"></a>00611     std::copy(src.A_mid_pt, src.A_mid_pt + 3, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#abb892372174ae16d4485cd46ceb5aac">A_mid_pt</a>);
<a name="l00612"></a>00612     std::copy(src.A_in_dir, src.A_in_dir + 3, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#a945c545c3b2ac14757f8cc6bf9326df">A_in_dir</a>);
<a name="l00613"></a>00613     std::copy(src.A_chord_mid_pt, src.A_chord_mid_pt + 3, <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#e5da612f0b29559898b76854005028f7">A_chord_mid_pt</a>);
<a name="l00614"></a>00614   }
<a name="l00615"></a>00615          
<a name="l00616"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">00616</a>   sphere_t <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#61808b252a9a77e07388ef89cb717781">A_S</a>;             
<a name="l00617"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">00617</a>   my_float_t <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#23ed7beb59a38ee8e970536506e46429">A_end_pts</a>[6];  
<a name="l00618"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#abb892372174ae16d4485cd46ceb5aac">00618</a>   my_float_t <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#abb892372174ae16d4485cd46ceb5aac">A_mid_pt</a>[3];   
<a name="l00619"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#a945c545c3b2ac14757f8cc6bf9326df">00619</a>   my_float_t <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#a945c545c3b2ac14757f8cc6bf9326df">A_in_dir</a>[3];   
<a name="l00620"></a><a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#e5da612f0b29559898b76854005028f7">00620</a>   my_float_t <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html#e5da612f0b29559898b76854005028f7">A_chord_mid_pt</a>[3];  
<a name="l00621"></a>00621 };
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 
<a name="l00625"></a>00625 
<a name="l00631"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html">00631</a> <span class="keyword">class </span><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html">iCircle</a> : <span class="keyword">public</span> sphere_t{
<a name="l00632"></a>00632 <span class="keyword">public</span>:
<a name="l00633"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#dc2d91b17a31b6efdf2507fbbd96adbf">00633</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#dc2d91b17a31b6efdf2507fbbd96adbf">iCircle</a>(<span class="keyword">const</span> my_float_t* C, my_float_t R, <span class="keyword">const</span> my_float_t* N, 
<a name="l00634"></a>00634           <span class="keyword">const</span> std::vector&lt;arc_t&gt;&amp; initial_arcs) 
<a name="l00635"></a>00635     : sphere_t(C, R), A_plane(N, C)
<a name="l00636"></a>00636   {
<a name="l00637"></a>00637     <span class="keywordflow">if</span>(initial_arcs.size())
<a name="l00638"></a>00638     {
<a name="l00639"></a>00639       A_full_circle = <span class="keyword">false</span>;
<a name="l00640"></a>00640       A_final_arcs = 
<a name="l00641"></a>00641         std::vector&lt;arc_t&gt;(initial_arcs.begin(), initial_arcs.end());
<a name="l00642"></a>00642     }<span class="keywordflow">else</span> A_full_circle = <span class="keyword">true</span>;
<a name="l00643"></a>00643     
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645 
<a name="l00647"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#a6c96857415afe3683f6ef6d51dd4d8c">00647</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#dc2d91b17a31b6efdf2507fbbd96adbf">iCircle</a>(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html">iCircle</a>&amp; src) : sphere_t(src), A_plane(src.A_plane)
<a name="l00648"></a>00648   {
<a name="l00649"></a>00649     <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#54491e02cadfba9d450243eb0012d5b6">do_copy</a>(src);
<a name="l00650"></a>00650   }
<a name="l00651"></a>00651 
<a name="l00653"></a>00653   <span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html">iCircle</a>&amp; 
<a name="l00654"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#afc268254b2b9d9f6f61a918a2a52dfc">00654</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#afc268254b2b9d9f6f61a918a2a52dfc">operator=</a>(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html">iCircle</a>&amp; src)
<a name="l00655"></a>00655   {
<a name="l00656"></a>00656     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;src){
<a name="l00657"></a>00657       <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#54491e02cadfba9d450243eb0012d5b6">do_copy</a>(src);
<a name="l00658"></a>00658       A_plane = src.A_plane;
<a name="l00659"></a>00659       sphere_t::operator= (src);
<a name="l00660"></a>00660     }
<a name="l00661"></a>00661     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00662"></a>00662   }
<a name="l00663"></a>00663 
<a name="l00665"></a>00665   <span class="keywordtype">void</span>
<a name="l00666"></a>00666   remove_overlap(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html">iCircle</a>&amp; other)
<a name="l00667"></a>00667   {
<a name="l00668"></a>00668     <span class="comment">// If the two iCircles do not intersect, we have nothing to do</span>
<a name="l00669"></a>00669     my_float_t D2 = dist_squared(center(), other.center());
<a name="l00670"></a>00670     my_float_t center_dist = radius() + other.radius();
<a name="l00671"></a>00671     <span class="keywordflow">if</span>(D2 &gt;= center_dist * center_dist) <span class="keywordflow">return</span>;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="comment">// Determine if any of self's arcs are full contained in other's volume</span>
<a name="l00674"></a>00674     std::vector&lt;arc_t&gt; tmp_arcs;
<a name="l00675"></a>00675     <span class="keywordflow">for</span>(uint i = 0; i &lt; A_final_arcs.size(); ++i){
<a name="l00676"></a>00676       <a class="code" href="classASCbase_1_1geometry_1_1arc__t.html">arc_t</a>&amp; AA = A_final_arcs[i];
<a name="l00677"></a>00677       <span class="comment">// We test the mid point to rule out the cases where the arc angle is</span>
<a name="l00678"></a>00678       <span class="comment">// greater than pi</span>
<a name="l00679"></a>00679       <span class="keywordflow">if</span>(!other.contains(AA.end_pts()) || !other.contains(AA.end_pts() + 3) ||
<a name="l00680"></a>00680          !other.contains(AA.get_mid_pt()))
<a name="l00681"></a>00681         tmp_arcs.push_back(AA);
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683     <span class="keywordflow">if</span>(!A_full_circle and tmp_arcs.size() &lt; 1) <span class="keywordflow">return</span>;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685     <span class="comment">// Check if self is fully contained in the other sphere</span>
<a name="l00686"></a>00686     <span class="keywordflow">if</span>(other.contains(center())){
<a name="l00687"></a>00687       my_float_t proj_pt[3];
<a name="l00688"></a>00688       other.sphere_t::project_point(center(), proj_pt);
<a name="l00689"></a>00689       <span class="keywordflow">if</span>(!contains(proj_pt)){
<a name="l00690"></a>00690         A_full_circle = <span class="keyword">false</span>;
<a name="l00691"></a>00691         A_final_arcs.clear();
<a name="l00692"></a>00692         <span class="keywordflow">return</span>;
<a name="l00693"></a>00693       }
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="comment">// Determine the line (chord) where the two circles intersect</span>
<a name="l00697"></a>00697     <span class="comment">// Plane intersection is the line Y = mX + b</span>
<a name="l00698"></a>00698     my_float_t m[3], b[3];
<a name="l00699"></a>00699     A_plane.intersection(other.<a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#6ae4379845c47b1fbad97a289f15fda0">A_plane</a>, m, b);
<a name="l00700"></a>00700     <span class="comment">//intersect_planes(A_N, A_d, other.A_N, other.A_d, m, b);</span>
<a name="l00701"></a>00701 
<a name="l00702"></a>00702     <span class="comment">// Determine intersection between line defined by m &amp; b and self</span>
<a name="l00703"></a>00703     my_float_t pts[6];
<a name="l00704"></a>00704     <span class="keywordtype">int</span> npts = intersection(m, b, pts); 
<a name="l00705"></a>00705     <span class="keywordflow">if</span>(!npts) <span class="keywordflow">return</span>;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     <span class="comment">// Get the 2 arcs for self -- both the remaining or kept arc and the</span>
<a name="l00708"></a>00708     <span class="comment">// removed arc or arc that falls inside the other sphere</span>
<a name="l00709"></a>00709     my_float_t mid_pt[3], my_dir[3], mid_pts[6], sq_dists[2];
<a name="l00710"></a>00710     mid_point(pts, pts + 3, mid_pt);
<a name="l00711"></a>00711     unit_vector(my_dir, mid_pt, center());
<a name="l00712"></a>00712     std::copy(center(), center() + 3, mid_pts);
<a name="l00713"></a>00713     std::copy(center(), center() + 3, mid_pts + 3);
<a name="l00714"></a>00714     my_axpy(3, radius(), my_dir, 1, mid_pts, 1);
<a name="l00715"></a>00715     my_axpy(3, -1.0 * radius(), my_dir, 1, mid_pts + 3, 1);
<a name="l00716"></a>00716     sq_dists[0] = dist_squared(other.center(), mid_pts);
<a name="l00717"></a>00717     sq_dists[1] = dist_squared(other.center(), mid_pts + 3);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719     my_float_t* keep_mid_pt = 0;
<a name="l00720"></a>00720     my_float_t* rm_mid_pt = 0;
<a name="l00721"></a>00721     <span class="keywordflow">if</span>(sq_dists[0] &lt; other.squared_radius() &amp;&amp;
<a name="l00722"></a>00722        sq_dists[1] &lt; other.squared_radius()){
<a name="l00723"></a>00723       err_msg(<span class="stringliteral">"sphere.H"</span>, <span class="stringliteral">"iCircle.remove_overlap()"</span>,
<a name="l00724"></a>00724               <span class="stringliteral">"Entire circle is contained in other circle"</span>);
<a name="l00725"></a>00725       <span class="keywordflow">return</span>;
<a name="l00726"></a>00726     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(sq_dists[0] &lt; other.squared_radius()){
<a name="l00727"></a>00727       keep_mid_pt = mid_pts + 3;
<a name="l00728"></a>00728       rm_mid_pt = mid_pts;
<a name="l00729"></a>00729     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(sq_dists[1] &lt; other.squared_radius()){
<a name="l00730"></a>00730       keep_mid_pt = mid_pts;
<a name="l00731"></a>00731       rm_mid_pt = mid_pts + 3;
<a name="l00732"></a>00732     }<span class="keywordflow">else</span>{
<a name="l00733"></a>00733       err_msg(<span class="stringliteral">"sphere.H"</span>, <span class="stringliteral">"iCircle.remove_overlap()"</span>,
<a name="l00734"></a>00734               <span class="stringliteral">"Circles do not intersect"</span>);
<a name="l00735"></a>00735       <span class="keywordflow">return</span>;
<a name="l00736"></a>00736     }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     <span class="keywordflow">if</span>(dist_squared(pts, pts + 3) &lt; 1E-14){
<a name="l00739"></a>00739       <span class="comment">// Keep arc is very small, the contribution of self to total difference is</span>
<a name="l00740"></a>00740       <span class="comment">// negligible</span>
<a name="l00741"></a>00741       <span class="keywordflow">if</span>(dist_squared(keep_mid_pt, pts) &lt; 1E-14){
<a name="l00742"></a>00742         A_full_circle = <span class="keyword">false</span>;
<a name="l00743"></a>00743         A_final_arcs.clear();
<a name="l00744"></a>00744       <span class="comment">// Remove arc is very small, the contribution of other to the total</span>
<a name="l00745"></a>00745       <span class="comment">// difference is negligible</span>
<a name="l00746"></a>00746       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dist_squared(rm_mid_pt, pts) &lt; 1E-14) <span class="keywordflow">return</span>;
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="comment">// In direction of overlap is the direction from the center to midpoint of</span>
<a name="l00750"></a>00750     <span class="comment">// chord</span>
<a name="l00751"></a>00751     arc_t keep_arc(*<span class="keyword">this</span>, pts, keep_mid_pt, pts + 3);
<a name="l00752"></a>00752    
<a name="l00753"></a>00753     <span class="comment">// Update the arc vector for self</span>
<a name="l00754"></a>00754     <span class="keywordflow">if</span>(A_full_circle){
<a name="l00755"></a>00755       A_full_circle = <span class="keyword">false</span>;
<a name="l00756"></a>00756       A_final_arcs.push_back(keep_arc);
<a name="l00757"></a>00757     }<span class="keywordflow">else</span>{
<a name="l00758"></a>00758       std::vector&lt;arc_t&gt; new_final_arcs;
<a name="l00759"></a>00759       <span class="keywordflow">for</span>(uint i = 0; i &lt; A_final_arcs.size(); ++i)
<a name="l00760"></a>00760         keep_arc.intersection(A_final_arcs[i], &amp;new_final_arcs);
<a name="l00761"></a>00761       A_final_arcs = new_final_arcs;
<a name="l00762"></a>00762     }
<a name="l00763"></a>00763   }
<a name="l00764"></a>00764 
<a name="l00766"></a>00766   <span class="keywordtype">bool</span>
<a name="l00767"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#214a76a297e276e2c0d6f4b07d34c731">00767</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#214a76a297e276e2c0d6f4b07d34c731">project_point</a>(<span class="keyword">const</span> my_float_t* pt, my_float_t* proj_pt, my_float_t *sq_dist,
<a name="l00768"></a>00768                 <span class="keyword">const</span> my_float_t tol=1.0)
<a name="l00769"></a>00769   {
<a name="l00770"></a>00770     my_float_t sq_tol = tol*tol;
<a name="l00771"></a>00771     my_float_t dist_to_plane = A_plane.<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#d07a8d10378c09fa6e685ac904c2646d">signed_dist</a>(pt);
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     <span class="comment">// 1st, project pt to plane</span>
<a name="l00774"></a>00774     <span class="comment">//my_float_t proj_pt[3];</span>
<a name="l00775"></a>00775     std::copy(pt, pt + 3, proj_pt);
<a name="l00776"></a>00776     my_axpy(3, -1.0 * dist_to_plane, A_plane.<a class="code" href="classASCbase_1_1geometry_1_1plane__t.html#46707f1b4f2a00ea36fc49e783d153b9">normal</a>(), 1, proj_pt, 1);
<a name="l00777"></a>00777  
<a name="l00778"></a>00778     <span class="comment">// 2nd, project the pt in plane to the circle (sphere restricted to the</span>
<a name="l00779"></a>00779     <span class="comment">// plane</span>
<a name="l00780"></a>00780     my_float_t in_plane_dir[3];
<a name="l00781"></a>00781     unit_vector(in_plane_dir, proj_pt, center());
<a name="l00782"></a>00782     std::copy(center(), center() + 3, proj_pt);
<a name="l00783"></a>00783     my_axpy(3, radius(), in_plane_dir, 1, proj_pt, 1);
<a name="l00784"></a>00784    
<a name="l00785"></a>00785     *sq_dist = dist_squared(proj_pt, pt);
<a name="l00786"></a>00786     <span class="keywordflow">if</span>(*sq_dist &gt; sq_tol) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00787"></a>00787      
<a name="l00788"></a>00788     <span class="keywordflow">if</span>(!A_full_circle){
<a name="l00789"></a>00789       <a class="code" href="structASCbase_1_1geometry_1_1iCircle_1_1point__type.html">point_type</a> pt_on_A;
<a name="l00790"></a>00790       std::vector&lt;point_type&gt; arc_pts;
<a name="l00791"></a>00791       std::vector&lt;my_float_t&gt; pts_sq_dists;
<a name="l00792"></a>00792       std::vector&lt;geometry::arc_t&gt;::const_iterator A;
<a name="l00793"></a>00793       <span class="keywordflow">for</span>(A = A_final_arcs.begin(); A &lt; A_final_arcs.end(); ++A){
<a name="l00794"></a>00794 <span class="comment">/*</span>
<a name="l00795"></a>00795 <span class="comment">        std::cout &lt;&lt; "  arc end points " &lt;&lt; A-&gt;end_pts()[0] &lt;&lt; " "</span>
<a name="l00796"></a>00796 <span class="comment">                  &lt;&lt; A-&gt;end_pts()[1] &lt;&lt; " " &lt;&lt; A-&gt;end_pts()[2] &lt;&lt; "   "</span>
<a name="l00797"></a>00797 <span class="comment">                  &lt;&lt; A-&gt;end_pts()[3] &lt;&lt; " " &lt;&lt; A-&gt;end_pts()[4] &lt;&lt; " "</span>
<a name="l00798"></a>00798 <span class="comment">                  &lt;&lt; A-&gt;end_pts()[5] &lt;&lt; "\n";</span>
<a name="l00799"></a>00799 <span class="comment">        std::cout &lt;&lt; "  arc in dir: " &lt;&lt; A-&gt;in_dir()[0] &lt;&lt; " "</span>
<a name="l00800"></a>00800 <span class="comment">                  &lt;&lt; A-&gt;in_dir()[1] &lt;&lt; " " &lt;&lt; A-&gt;in_dir()[2] &lt;&lt; "\n";</span>
<a name="l00801"></a>00801 <span class="comment">*/</span>
<a name="l00802"></a>00802         <span class="comment">// If the projected point is in the arc, keep it</span>
<a name="l00803"></a>00803         <span class="keywordflow">if</span>(A-&gt;contains(proj_pt)){
<a name="l00804"></a>00804 <span class="comment">//          std::cout &lt;&lt; "  Arc contains pt\n";</span>
<a name="l00805"></a>00805           std::copy(proj_pt, proj_pt + 3, pt_on_A.<a class="code" href="structASCbase_1_1geometry_1_1iCircle_1_1point__type.html#b2fba8f10a57aa81097fe33f7026628f">pt</a>);
<a name="l00806"></a>00806           arc_pts.push_back(pt_on_A);
<a name="l00807"></a>00807           pts_sq_dists.push_back(*sq_dist);
<a name="l00808"></a>00808         <span class="comment">// Otherwise choose the closest end point of the arc</span>
<a name="l00809"></a>00809         }<span class="keywordflow">else</span>{
<a name="l00810"></a>00810 <span class="comment">//          std::cout &lt;&lt; "  Arc does not contain pt\n";</span>
<a name="l00811"></a>00811           my_float_t d2z[] = { dist_squared(A-&gt;end_pts(), pt),
<a name="l00812"></a>00812                                dist_squared(A-&gt;end_pts() + 3, pt) };
<a name="l00813"></a>00813           my_float_t min_d2;
<a name="l00814"></a>00814           <span class="keywordtype">int</span> idx = argmin&lt;my_float_t&gt;(d2z, 2, &amp;min_d2);
<a name="l00815"></a>00815           <span class="keywordflow">if</span>(min_d2 &lt;= sq_tol){
<a name="l00816"></a>00816             std::copy(A-&gt;end_pts() + 3*idx, A-&gt;end_pts() + 3*idx + 3,
<a name="l00817"></a>00817                       pt_on_A.<a class="code" href="structASCbase_1_1geometry_1_1iCircle_1_1point__type.html#b2fba8f10a57aa81097fe33f7026628f">pt</a>);
<a name="l00818"></a>00818             arc_pts.push_back(pt_on_A);
<a name="l00819"></a>00819             pts_sq_dists.push_back(min_d2);
<a name="l00820"></a>00820           }
<a name="l00821"></a>00821         }
<a name="l00822"></a>00822       }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824       <span class="comment">// Get the closest point of all computed points</span>
<a name="l00825"></a>00825       <span class="keywordflow">if</span>(pts_sq_dists.size()){
<a name="l00826"></a>00826         my_float_t min_dist = pts_sq_dists[0];
<a name="l00827"></a>00827         uint idx = 0;
<a name="l00828"></a>00828         <span class="keywordflow">for</span>(uint i = 1; i &lt; pts_sq_dists.size(); ++i){
<a name="l00829"></a>00829           <span class="keywordflow">if</span>(pts_sq_dists[i] &lt; min_dist){
<a name="l00830"></a>00830             min_dist = pts_sq_dists[i];
<a name="l00831"></a>00831             idx = i;
<a name="l00832"></a>00832           }
<a name="l00833"></a>00833         }
<a name="l00834"></a>00834         std::copy(arc_pts[idx].pt, arc_pts[idx].pt + 3, proj_pt);
<a name="l00835"></a>00835         *sq_dist = min_dist; 
<a name="l00836"></a>00836       }<span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00839"></a>00839   }
<a name="l00840"></a>00840 
<a name="l00843"></a>00843   <span class="keywordtype">bool</span>
<a name="l00844"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#a3821e31fe1ca72a92c040bebd0cbab7">00844</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#a3821e31fe1ca72a92c040bebd0cbab7">full_circle</a>()<span class="keyword"> const</span>
<a name="l00845"></a>00845 <span class="keyword">  </span>{ <span class="keywordflow">return</span> A_full_circle; }
<a name="l00846"></a>00846 
<a name="l00848"></a>00848   uint
<a name="l00849"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#b3746f127fd9a5e4eda03b91e61c1325">00849</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#b3746f127fd9a5e4eda03b91e61c1325">num_final_arcs</a>()<span class="keyword"> const</span>
<a name="l00850"></a>00850 <span class="keyword">  </span>{ <span class="keywordflow">return</span> A_final_arcs.size(); }
<a name="l00851"></a>00851 
<a name="l00853"></a>00853   std::vector&lt;arc_t&gt;::const_iterator
<a name="l00854"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#afd4529a5f5d5fdc4bb8828a5da80e38">00854</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#afd4529a5f5d5fdc4bb8828a5da80e38">final_arcs_begin</a>()<span class="keyword"> const</span>
<a name="l00855"></a>00855 <span class="keyword">  </span>{ <span class="keywordflow">return</span> A_final_arcs.begin(); }
<a name="l00856"></a>00856 
<a name="l00858"></a>00858   std::vector&lt;arc_t&gt;::const_iterator
<a name="l00859"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#218c0440280ff4520f9f8e40f35688dc">00859</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#218c0440280ff4520f9f8e40f35688dc">final_arcs_end</a>()<span class="keyword"> const</span>
<a name="l00860"></a>00860 <span class="keyword">  </span>{ <span class="keywordflow">return</span> A_final_arcs.end(); }
<a name="l00861"></a>00861 
<a name="l00863"></a><a class="code" href="structASCbase_1_1geometry_1_1iCircle_1_1point__type.html">00863</a>   <span class="keyword">struct </span><a class="code" href="structASCbase_1_1geometry_1_1iCircle_1_1point__type.html">point_type</a>{
<a name="l00864"></a>00864     my_float_t pt[3];
<a name="l00865"></a>00865   };
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="keyword">private</span>:
<a name="l00869"></a>00869   <span class="keywordtype">void</span>
<a name="l00870"></a><a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#54491e02cadfba9d450243eb0012d5b6">00870</a>   <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#54491e02cadfba9d450243eb0012d5b6">do_copy</a>(<span class="keyword">const</span> <a class="code" href="classASCbase_1_1geometry_1_1iCircle.html">iCircle</a>&amp; src)
<a name="l00871"></a>00871   {
<a name="l00872"></a>00872     A_full_circle = src.<a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#2ddf6cfc4477e5bdba558719c78e7f91">A_full_circle</a>;
<a name="l00873"></a>00873     A_final_arcs = src.<a class="code" href="classASCbase_1_1geometry_1_1iCircle.html#1614741330df5d735e025d3cdffc035c">A_final_arcs</a>;
<a name="l00874"></a>00874   }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="keywordtype">bool</span> A_full_circle; 
<a name="l00877"></a>00877   <a class="code" href="classASCbase_1_1geometry_1_1plane__t.html">plane_t</a> A_plane;
<a name="l00878"></a>00878   std::vector&lt;arc_t&gt; A_final_arcs;
<a name="l00879"></a>00879 };
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 } <span class="comment">// end namespace utils</span>
<a name="l00884"></a>00884 } <span class="comment">// end namespace ASCbase</span>
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Apr 3 23:09:18 2012 for simsite3d by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
