<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>simsite3d: ScoreRigidAlignments.H Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>ScoreRigidAlignments.H</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************e</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2006,2007, Michigan State University (MSU) Board of Trustees.</span>
<a name="l00003"></a>00003 <span class="comment"> *   All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * This file is part of the SimSite3D Software project.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00008"></a>00008 <span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00009"></a>00009 <span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a name="l00010"></a>00010 <span class="comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<a name="l00011"></a>00011 <span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a name="l00012"></a>00012 <span class="comment"> * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<a name="l00013"></a>00013 <span class="comment"> * THE SOFTWARE.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * Authors: Jeffrey Van Voorst, jeff.vanvoorst@gmail.com</span>
<a name="l00016"></a>00016 <span class="comment"> *          Leslie Kuhn, Ph.D., KuhnL@msu.edu </span>
<a name="l00017"></a>00017 <span class="comment"> *****************************************************************************/</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef _SCORE_RIGID_ALIGNMENTS_HEADER_FILE</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define _SCORE_RIGID_ALIGNMENTS_HEADER_FILE</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;ScoreMapBase.H&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;AlignDataWithPreIKData.H&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;AlignDataWithProtLigScore.H&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;new_tri_test.H&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;DbaseSitemap.H&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;ModelSitemap.H&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;ProtLigScore.H&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;IK_tests.H&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="keyword">namespace </span>SimSite3D{
<a name="l00033"></a>00033 
<a name="l00036"></a>00036 
<a name="l00051"></a>00051 <span class="keyword">template</span> &lt; <span class="keyword">class</span> tier1_SF, <span class="keyword">class</span> tier2_SF, <span class="keyword">class</span> align_T &gt;
<a name="l00052"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html">00052</a> <span class="keyword">class </span><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html">ScoreRigidAlignments</a> : <span class="keyword">public</span> <a class="code" href="classSimSite3D_1_1ScoreMapBase.html">ScoreMapBase</a> {
<a name="l00053"></a>00053 <span class="keyword">public</span>:
<a name="l00054"></a>00054   <span class="keyword">typedef</span> align_T                                       rigid_align_obj;
<a name="l00055"></a>00055   <span class="keyword">typedef</span> std::vector&lt;align_T&gt;                          rigid_align_vec; 
<a name="l00056"></a>00056   <span class="keyword">typedef</span> <span class="keyword">typename</span> rigid_align_vec::iterator            rigid_align_vi; 
<a name="l00057"></a>00057   <span class="keyword">typedef</span> <span class="keyword">typename</span> rigid_align_vec::const_iterator      rigid_align_vci; 
<a name="l00058"></a>00058   <span class="keyword">typedef</span> std::pair&lt;my_float_t, rigid_align_vi&gt;         align_pair;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="keyword">typedef</span> <span class="keyword">typename</span> tier1_SF::score_cmp                  tier1_score_cmp;
<a name="l00061"></a>00061   <span class="keyword">typedef</span> <span class="keyword">typename</span> tier2_SF::score_cmp                  tier2_score_cmp;
<a name="l00062"></a>00062   <span class="keyword">typedef</span> std::multimap&lt;my_float_t, rigid_align_vi, tier1_score_cmp&gt;
<a name="l00063"></a>00063                                                         tier1_score_mmap;
<a name="l00064"></a>00064   <span class="keyword">typedef</span> std::multimap&lt;my_float_t, rigid_align_vi, tier2_score_cmp&gt;
<a name="l00065"></a>00065                                                         tier2_score_mmap;
<a name="l00066"></a>00066   <span class="keyword">typedef</span> <span class="keyword">typename</span> tier1_score_mmap::iterator           tier1_score_mmi;
<a name="l00067"></a>00067   <span class="keyword">typedef</span> <span class="keyword">typename</span> tier2_score_mmap::iterator           tier2_score_mmi;
<a name="l00068"></a>00068   <span class="keyword">typedef</span> <span class="keyword">typename</span> tier1_score_mmap::const_iterator     tier1_score_mmci;
<a name="l00069"></a>00069   <span class="keyword">typedef</span> <span class="keyword">typename</span> tier2_score_mmap::const_iterator     tier2_score_mmci;
<a name="l00070"></a>00070 
<a name="l00072"></a>00072 
<a name="l00079"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#106865e65c8b845a550573c22e803d4b">00079</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#106865e65c8b845a550573c22e803d4b">ScoreRigidAlignments</a>(<a class="code" href="classSimSite3D_1_1ModelSitemap.html">ModelSitemap</a>* model_in, <span class="keyword">const</span> <a class="code" href="classSimSite3D_1_1SearchParameters.html">SearchParameters</a>&amp; params)
<a name="l00080"></a>00080     : <a class="code" href="classSimSite3D_1_1ScoreMapBase.html">ScoreMapBase</a>(params), A_my_IK(params)
<a name="l00081"></a>00081   {
<a name="l00082"></a>00082     A_orient_num = 0;
<a name="l00083"></a>00083     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a> = model_in;
<a name="l00084"></a>00084     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#7806e9477e19018757ac9095212e1263">A_score_cutoff</a> = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#2ee1752f506f23f99dc8639465c83015">score_cutoff</a>;
<a name="l00085"></a>00085     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#896fa695aef8944e5a685ba3ef552b0c">A_max_num_aligns</a> = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#275f0141e87e686c4c8ee55d9062ae81">num_scores_to_keep</a>;
<a name="l00086"></a>00086     std::cout &lt;&lt; <span class="stringliteral">"number of scores to keep: "</span> &lt;&lt; <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#896fa695aef8944e5a685ba3ef552b0c">A_max_num_aligns</a> &lt;&lt; std::endl;
<a name="l00087"></a>00087     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#5412c0788cb1612caa586487861973c1">A_max_tier1_aligns</a> = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#d8fa144982e1f3a459b6797170fec1e9">max_tier1_aligns</a>;
<a name="l00088"></a>00088     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a> = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#b82481de1a76a7e1ef2701225f4e8e2b">min_num_atoms</a>;
<a name="l00089"></a>00089     A_do_IK = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#ae98a5075be2f4c92734f47223076e6c">do_IK</a>;
<a name="l00090"></a>00090     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#c07f83e7959ea22d965c62791d68fef2">normalize_scores</a> = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#4265eb5c3b8cd524159bcefd855458fa">normalize</a>;
<a name="l00091"></a>00091     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3d17d020c019cac00a83e36e22c1ffc6">dbase_ligs</a> = params.<a class="code" href="classSimSite3D_1_1BaseParameters.html#d6b47ad4d8d7460817551da93171de4a">dbase_ligs</a>;
<a name="l00092"></a>00092     A_proj_output = params.<a class="code" href="classSimSite3D_1_1BaseParameters.html#96522745ba23c6aac7d9258d65aac545">proj_output</a>;
<a name="l00093"></a>00093     <span class="keywordflow">if</span>(params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#770e3c6ff6ae15a21330d15dcfe3d4d5">score_str</a>.length()) A_score_method_str = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#770e3c6ff6ae15a21330d15dcfe3d4d5">score_str</a>;
<a name="l00094"></a>00094     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#c07f83e7959ea22d965c62791d68fef2">normalize_scores</a>){
<a name="l00095"></a>00095       <span class="keyword">const</span> my_float_t* norms = <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>-&gt;<a class="code" href="classSimSite3D_1_1Sitemap.html#df498664611c91d15cf7234d8ef91dbc">get_norm_moments</a>();
<a name="l00096"></a>00096       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a> = norms[0];
<a name="l00097"></a>00097       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a> = norms[1];
<a name="l00098"></a>00098     }<span class="keywordflow">else</span>{
<a name="l00099"></a>00099       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a> = 0;
<a name="l00100"></a>00100       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a> = 1;
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102     A_struct_id_field = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#6dbd7bf284c1dbfd2c2af2becf89a078">add_struct_id_field</a>;
<a name="l00103"></a>00103   
<a name="l00104"></a>00104     std::string chaff;
<a name="l00105"></a>00105     get_path_and_struct_id(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>-&gt;<a class="code" href="classSimSite3D_1_1Sitemap.html#aaf9fd841e8f5a03b2b7b756240bbe82">atoms_file_name</a>(), &amp;chaff, 
<a name="l00106"></a>00106                            &amp;A_model_struct_id);
<a name="l00107"></a>00107     A_model_struct_id = 
<a name="l00108"></a>00108       A_model_struct_id.substr(0, A_model_struct_id.length() - 2);
<a name="l00109"></a>00109     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreMapBase.html#42d2d13e5fa5d7492495dd531246f8a5">A_prot_lig_score</a>){
<a name="l00110"></a>00110       std::cout &lt;&lt; <span class="stringliteral">"Protein-ligand scoring will be computed for saved "</span>
<a name="l00111"></a>00111                 &lt;&lt; <span class="stringliteral">"orientations\n"</span>;
<a name="l00112"></a>00112       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">A_query_prot</a> = <span class="keyword">new</span> <a class="code" href="classSimSite3D_1_1PDBStructure.html">PDBStructure</a>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>-&gt;<a class="code" href="classSimSite3D_1_1Sitemap.html#aaf9fd841e8f5a03b2b7b756240bbe82">atoms_file_name</a>());
<a name="l00113"></a>00113     }<span class="keywordflow">else</span>{ 
<a name="l00114"></a>00114       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">A_query_prot</a> = 0;
<a name="l00115"></a>00115       std::cout &lt;&lt; <span class="stringliteral">"Protein-ligand scoring is OFF\n"</span>;
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#14c7215836a55728fa4225078b31cad7">A_write_ligands</a> = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#8f581cefd00526d81c5db9e7f2e53dd7">write_ligands</a>;
<a name="l00119"></a>00119     A_fine_tune_tier2_alignments = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#7e249d3358f464048cca7f574052e844">fine_tune_tier2_alignments</a>;
<a name="l00120"></a>00120     A_fine_tune_best_tier2_alignment = params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#6c449d3293b369f0c71e875e14d2039a">fine_tune_best_tier2_alignment</a>;
<a name="l00121"></a>00121 <span class="comment">//    if(A_fine_tune_tier2_alignments || A_fine_tune_best_tier2_alignment)</span>
<a name="l00122"></a>00122 <span class="comment">//      std::cout &lt;&lt; "need to check for convergence\n";</span>
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     <span class="keywordflow">if</span>(params.<a class="code" href="classSimSite3D_1_1SearchParameters.html#dcb623f26a6aabaf855021f954cee078">scale_terms</a>){
<a name="l00125"></a>00125       std::cout &lt;&lt; <span class="stringliteral">"Using scaled terms for scoring\n"</span>;
<a name="l00126"></a>00126       A_tier1_score_class.set_scale_terms(<span class="keyword">true</span>);      
<a name="l00127"></a>00127       A_tier2_score_class.set_scale_terms(<span class="keyword">true</span>);      
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129   }
<a name="l00130"></a>00130 
<a name="l00132"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#9c5edad1dcd9af6c0150ef7d8429ad47">00132</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#9c5edad1dcd9af6c0150ef7d8429ad47">~ScoreRigidAlignments</a>() 
<a name="l00133"></a>00133   { 
<a name="l00134"></a>00134     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">A_query_prot</a>) <span class="keyword">delete</span> <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">A_query_prot</a>; 
<a name="l00135"></a>00135     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">A_query_prot</a> = 0;
<a name="l00136"></a>00136   }
<a name="l00137"></a>00137 
<a name="l00139"></a>00139 
<a name="l00146"></a>00146   <span class="keywordtype">bool</span>
<a name="l00147"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e078164dfaa7d414d997fc2274de48f3">00147</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e078164dfaa7d414d997fc2274de48f3">score_alignments</a>(rigid_align_vec&amp; aligns, <a class="code" href="classSimSite3D_1_1DbaseSitemap.html">DbaseSitemap</a>* dbase_site,
<a name="l00148"></a>00148                    std::ostream&amp; results_out = std::cout,
<a name="l00149"></a>00149                    std::ostream&amp; rigid_results_out = std::cout)
<a name="l00150"></a>00150   {
<a name="l00151"></a>00151     <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> *dbase_ligand = 0;
<a name="l00152"></a>00152     std::string dbase_struct_id, dbase_mol_id;
<a name="l00153"></a>00153     <span class="keywordflow">if</span>(!<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#a2c37b383be18dec552610eacad948fa">load_ligand</a>(dbase_site-&gt;<a class="code" href="classSimSite3D_1_1Sitemap.html#cb41876f6caf930dbfd134532ba02a0c">ligand_file_name</a>(), 
<a name="l00154"></a>00154                     dbase_site-&gt;<a class="code" href="classSimSite3D_1_1Sitemap.html#aaf9fd841e8f5a03b2b7b756240bbe82">atoms_file_name</a>(), 
<a name="l00155"></a>00155                     &amp;dbase_ligand, &amp;dbase_struct_id, &amp;dbase_mol_id)) 
<a name="l00156"></a>00156       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00157"></a>00157     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreMapBase.html#42d2d13e5fa5d7492495dd531246f8a5">A_prot_lig_score</a>)
<a name="l00158"></a>00158       dbase_ligand-&gt;<a class="code" href="classSimSite3D_1_1mol2File.html#cd1b6001933a4461f79c35d2ed482daa">calc_charge_sums</a>();
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="comment">// forced flush for debugging</span>
<a name="l00161"></a>00161     std::cout &lt;&lt; <span class="stringliteral">"Comparing "</span> &lt;&lt; A_model_struct_id &lt;&lt; <span class="stringliteral">" to "</span> 
<a name="l00162"></a>00162               &lt;&lt; dbase_struct_id &lt;&lt; std::endl;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     tier2_score_mmap top_tier2_aligns;
<a name="l00165"></a>00165     <span class="keywordflow">if</span>(A_tier1_score_class.score_is_noop()){
<a name="l00166"></a>00166       <span class="comment">// "Single tier" scoring</span>
<a name="l00167"></a>00167 <span class="comment">//      std::cout &lt;&lt; "inside \"single tier\" scoring --- num aligns: " </span>
<a name="l00168"></a>00168 <span class="comment">//                &lt;&lt; aligns.size() &lt;&lt; "\n\n";</span>
<a name="l00169"></a>00169       <span class="keywordflow">if</span>(!<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e078164dfaa7d414d997fc2274de48f3">score_alignments</a>(aligns, dbase_site, dbase_ligand, dbase_struct_id, 
<a name="l00170"></a>00170                            dbase_mol_id, &amp;top_tier2_aligns, rigid_results_out)){
<a name="l00171"></a>00171         <span class="keywordflow">if</span>(dbase_ligand) <span class="keyword">delete</span>(dbase_ligand); 
<a name="l00172"></a>00172         dbase_ligand = 0; 
<a name="l00173"></a>00173         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l00174"></a>00174       } 
<a name="l00175"></a>00175     }<span class="keywordflow">else</span>{
<a name="l00176"></a>00176       <span class="comment">// First tier of scoring (scoring sieve)</span>
<a name="l00177"></a>00177       tier1_score_mmap top_tier1_aligns;
<a name="l00178"></a>00178       <span class="keywordflow">if</span>(!<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#b8dc3d46b8a573926943ecf0b0a6ae0d">score_tier1_alignments</a>(aligns, dbase_site, dbase_ligand, 
<a name="l00179"></a>00179                                  &amp;top_tier1_aligns)){
<a name="l00180"></a>00180         <span class="keywordflow">if</span>(dbase_ligand) <span class="keyword">delete</span>(dbase_ligand);
<a name="l00181"></a>00181         dbase_ligand = 0;
<a name="l00182"></a>00182         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00183"></a>00183       }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185       <span class="comment">// Second tier scoring (second scoring sieve)</span>
<a name="l00186"></a>00186       <span class="keywordflow">if</span>(!<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#280977dd9ab68c9c274ede4ad3bf8c1c">score_tier2_alignments</a>(top_tier1_aligns, dbase_site, dbase_ligand, 
<a name="l00187"></a>00187                                  dbase_struct_id, dbase_mol_id,
<a name="l00188"></a>00188                                  &amp;top_tier2_aligns, rigid_results_out)){
<a name="l00189"></a>00189         <span class="keywordflow">if</span>(dbase_ligand) <span class="keyword">delete</span>(dbase_ligand);
<a name="l00190"></a>00190         dbase_ligand = 0;
<a name="l00191"></a>00191         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00192"></a>00192       }
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     <span class="keywordflow">if</span>(dbase_ligand &amp;&amp; top_tier2_aligns.size() &gt; 0){
<a name="l00196"></a>00196       <span class="comment">// compute affi &amp; orient score</span>
<a name="l00197"></a>00197       <span class="keywordflow">if</span>(top_tier2_aligns.begin()-&gt;second-&gt;compute_prot_lig_score())
<a name="l00198"></a>00198         <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#4e0ef1c8fe1ed27a93385ec78ca35bf7">score_protein_ligand_interactions</a>(&amp;top_tier2_aligns);
<a name="l00199"></a>00199 
<a name="l00200"></a>00200       <span class="comment">// Write out ligands and reclaim memory</span>
<a name="l00201"></a>00201       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#4adb8e45da74e0d142fd29e1b1f104dc">handle_ligands</a>(top_tier2_aligns, dbase_ligand, dbase_mol_id);
<a name="l00202"></a>00202       <span class="keyword">delete</span>(dbase_ligand);
<a name="l00203"></a>00203       dbase_ligand = 0;
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#ec86b7fcea8af70b5b4e7cb7dc87383a">report_alignments</a>(top_tier2_aligns, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#14c7215836a55728fa4225078b31cad7">A_write_ligands</a>, dbase_struct_id, 
<a name="l00207"></a>00207                       dbase_mol_id, results_out);
<a name="l00208"></a>00208     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00209"></a>00209   }
<a name="l00210"></a>00210 
<a name="l00212"></a>00212   <span class="keyword">virtual</span> <span class="keywordtype">void</span> 
<a name="l00213"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3668ef98e3e48111f868cfd5ee139565">00213</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3668ef98e3e48111f868cfd5ee139565">write_score_header</a>(std::ostream&amp; out)
<a name="l00214"></a>00214   {
<a name="l00215"></a>00215    <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#c07f83e7959ea22d965c62791d68fef2">normalize_scores</a>){
<a name="l00216"></a>00216       out &lt;&lt; std::setw(50) &lt;&lt; <span class="stringliteral">"# Mean of raw scores of diverse sitemaps:"</span>
<a name="l00217"></a>00217           &lt;&lt; <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a> &lt;&lt; <span class="stringliteral">"\n"</span>
<a name="l00218"></a>00218           &lt;&lt; std::setw(50) &lt;&lt; <span class="stringliteral">"# Stdev of raw scores of diverse sitemaps:"</span>
<a name="l00219"></a>00219           &lt;&lt; <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a> &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00220"></a>00220     }<span class="keywordflow">else</span> out &lt;&lt; <span class="stringliteral">"# SimSite3D alignments scores are not normalized\n"</span>;
<a name="l00221"></a>00221   
<a name="l00222"></a>00222     out &lt;&lt; <span class="stringliteral">"#\n# Fields:\n"</span>;
<a name="l00223"></a>00223     <span class="keywordflow">if</span>(A_struct_id_field) out &lt;&lt; <span class="stringliteral">"# 0) Database structure id\n"</span>;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     std::vector&lt;std::string&gt; fields;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     std::string tmp = 
<a name="l00228"></a>00228       <span class="stringliteral">"Name of ligand fragment corresponding to the score record (line)"</span>;
<a name="l00229"></a>00229     fields.push_back(tmp);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     align_T tmp_align; 
<a name="l00232"></a>00232     tmp_align.get_score_field_labels(&amp;fields, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#c07f83e7959ea22d965c62791d68fef2">normalize_scores</a>);
<a name="l00233"></a>00233    
<a name="l00234"></a>00234     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreMapBase.html#b6bfd4fcc3263c7ee1cc86c856cea184">ext_SF_id</a>.length() &amp;&amp; <a class="code" href="classSimSite3D_1_1ScoreMapBase.html#b6bfd4fcc3263c7ee1cc86c856cea184">ext_SF_id</a> != <span class="stringliteral">"NONE"</span>){
<a name="l00235"></a>00235       std::vector&lt;std::string&gt; sf_names;
<a name="l00236"></a>00236       <a class="code" href="classSimSite3D_1_1ScoreMapBase.html#b5ee9de7e756e9c6ee3058c475a95958">get_ext_SF_names</a>(&amp;sf_names);
<a name="l00237"></a>00237       <span class="keywordflow">for</span>(uint i = 0; i &lt; sf_names.size(); ++i){
<a name="l00238"></a>00238         tmp = sf_names[i];
<a name="l00239"></a>00239         tmp += <span class="stringliteral">" score of target ligand fragment in query pocket"</span>;
<a name="l00240"></a>00240         fields.push_back(tmp);
<a name="l00241"></a>00241       }    
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     <span class="keywordflow">if</span>(A_fine_tune_tier2_alignments){
<a name="l00245"></a>00245       out &lt;&lt; <span class="stringliteral">"# NOTE: the matchprint is NOT valid in the RIGID file\n"</span>;
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248     <span class="keywordflow">for</span>(uint i = 0; i &lt; fields.size(); ++i){
<a name="l00249"></a>00249       out &lt;&lt; <span class="stringliteral">"# "</span> &lt;&lt; std::setw(2) &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">") "</span> &lt;&lt; fields[i] &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   }
<a name="l00253"></a>00253 
<a name="l00255"></a>00255 
<a name="l00260"></a>00260   <span class="keywordtype">bool</span> 
<a name="l00261"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#b8dc3d46b8a573926943ecf0b0a6ae0d">00261</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#b8dc3d46b8a573926943ecf0b0a6ae0d">score_tier1_alignments</a>(rigid_align_vec&amp; aligns_in, <a class="code" href="classSimSite3D_1_1DbaseSitemap.html">DbaseSitemap</a>* search,
<a name="l00262"></a>00262                          <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> *lig_file, tier1_score_mmap *top_aligns)
<a name="l00263"></a>00263   {
<a name="l00264"></a>00264     <span class="keywordflow">if</span>(aligns_in.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00265"></a>00265     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a> &gt; 0 &amp;&amp; !lig_file) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     <span class="comment">// we use an exponent of 30 as we may have float or double and</span>
<a name="l00268"></a>00268     <span class="comment">// I don't want to worry about overflow because of nonsymmetry of </span>
<a name="l00269"></a>00269     <span class="comment">// machine numbers</span>
<a name="l00270"></a>00270     my_float_t score_cutoff = (<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#13a5468270fa523e191d1428030fd015">A_tier1_score_cmp</a>(0,1) ? 1E+30 : -1E+30);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     rigid_align_vi align;
<a name="l00273"></a>00273     <span class="keywordflow">for</span>(align = aligns_in.begin(); align &lt; aligns_in.end(); ++align){
<a name="l00274"></a>00274       align-&gt;set_number_of_orientations(aligns_in.size());
<a name="l00275"></a>00275       blah(align, &amp;A_tier1_score_class, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#13a5468270fa523e191d1428030fd015">A_tier1_score_cmp</a>, top_aligns, lig_file,
<a name="l00276"></a>00276            <span class="keyword">true</span>, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#5412c0788cb1612caa586487861973c1">A_max_tier1_aligns</a>, score_cutoff, <span class="keyword">false</span>, search);
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00279"></a>00279   }
<a name="l00280"></a>00280 
<a name="l00282"></a>00282   <span class="keywordtype">bool</span> 
<a name="l00283"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#280977dd9ab68c9c274ede4ad3bf8c1c">00283</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#280977dd9ab68c9c274ede4ad3bf8c1c">score_tier2_alignments</a>(tier1_score_mmap &amp;align_map, <a class="code" href="classSimSite3D_1_1DbaseSitemap.html">DbaseSitemap</a>* dset_site,
<a name="l00284"></a>00284                          <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> *lig_file, <span class="keyword">const</span> std::string&amp; db_struct_id,
<a name="l00285"></a>00285                          <span class="keyword">const</span> std::string&amp; db_mol_id, 
<a name="l00286"></a>00286                          tier2_score_mmap *top_aligns,
<a name="l00287"></a>00287                          std::ostream&amp; rigid_results_out)
<a name="l00288"></a>00288   {
<a name="l00289"></a>00289 <span class="comment">//    std::cout &lt;&lt; "need to adjust ligand orientation after rigid refinement of sites\n";</span>
<a name="l00290"></a>00290     <span class="keywordflow">if</span>(align_map.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00291"></a>00291     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a> &gt; 0 &amp;&amp; !lig_file) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="comment">// Rename align to something else and get a reference to the align_vi</span>
<a name="l00294"></a>00294     tier1_score_mmci align_map_iter = align_map.begin();
<a name="l00295"></a>00295     <span class="keywordflow">for</span>( ; align_map_iter != align_map.end(); ++align_map_iter){
<a name="l00296"></a>00296       blah(align_map_iter-&gt;second, &amp;A_tier2_score_class, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f70ab6bb6b22b59758853f0326c8fece">A_tier2_score_cmp</a>,
<a name="l00297"></a>00297            top_aligns, lig_file, <span class="keyword">false</span>, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#896fa695aef8944e5a685ba3ef552b0c">A_max_num_aligns</a>, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#7806e9477e19018757ac9095212e1263">A_score_cutoff</a>,
<a name="l00298"></a>00298            A_fine_tune_tier2_alignments, dset_site);
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     <span class="comment">// If we wanted only to fine tune the best scoring alignment at this level,</span>
<a name="l00302"></a>00302     <span class="comment">// do it here</span>
<a name="l00303"></a>00303     <span class="keywordflow">if</span>(top_aligns-&gt;size() &amp;&amp; A_fine_tune_best_tier2_alignment)
<a name="l00304"></a>00304       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#1d8b66d8f4810212f8f8187c061d74f0">refine_best_alignment</a>(&amp;A_tier2_score_class, top_aligns, dset_site, 
<a name="l00305"></a>00305                             lig_file, db_struct_id, db_mol_id, 
<a name="l00306"></a>00306                             rigid_results_out);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310 
<a name="l00312"></a>00312 
<a name="l00319"></a>00319   <span class="keywordtype">bool</span> 
<a name="l00320"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#c843eb1e867692b154abde2456b214d4">00320</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e078164dfaa7d414d997fc2274de48f3">score_alignments</a>(rigid_align_vec&amp; aligns_in, <a class="code" href="classSimSite3D_1_1DbaseSitemap.html">DbaseSitemap</a>* dset_site,
<a name="l00321"></a>00321                    <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> *lig_file, <span class="keyword">const</span> std::string&amp; db_struct_id,
<a name="l00322"></a>00322                    <span class="keyword">const</span> std::string&amp; db_mol_id, tier2_score_mmap *top_aligns, 
<a name="l00323"></a>00323                    std::ostream&amp; rigid_results_out)
<a name="l00324"></a>00324   {
<a name="l00325"></a>00325     <span class="keywordflow">if</span>(aligns_in.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00326"></a>00326     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a> &gt; 0 &amp;&amp; !lig_file) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     rigid_align_vi align;
<a name="l00329"></a>00329     <span class="keywordflow">for</span>(align = aligns_in.begin(); align &lt; aligns_in.end(); ++align){
<a name="l00330"></a>00330       align-&gt;set_number_of_orientations(aligns_in.size());
<a name="l00331"></a>00331       blah(align, &amp;A_tier2_score_class, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f70ab6bb6b22b59758853f0326c8fece">A_tier2_score_cmp</a>, top_aligns, 
<a name="l00332"></a>00332            lig_file, <span class="keyword">true</span>, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#896fa695aef8944e5a685ba3ef552b0c">A_max_num_aligns</a>, <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#7806e9477e19018757ac9095212e1263">A_score_cutoff</a>, 
<a name="l00333"></a>00333            A_fine_tune_tier2_alignments, dset_site);
<a name="l00334"></a>00334     }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     <span class="comment">// If we wanted only to fine tune the best scoring alignment, do it here</span>
<a name="l00337"></a>00337     <span class="keywordflow">if</span>(top_aligns-&gt;size() &amp;&amp; A_fine_tune_best_tier2_alignment)
<a name="l00338"></a>00338       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#1d8b66d8f4810212f8f8187c061d74f0">refine_best_alignment</a>(&amp;A_tier2_score_class, top_aligns, dset_site, 
<a name="l00339"></a>00339                             lig_file, db_struct_id, db_mol_id, 
<a name="l00340"></a>00340                             rigid_results_out);
<a name="l00341"></a>00341     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00342"></a>00342   }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="keyword">template</span> &lt;<span class="keyword">class</span> score_T, <span class="keyword">class</span> cmp_T&gt; <span class="keywordtype">bool</span>
<a name="l00345"></a>00345   blah(rigid_align_vi align, score_T *score_method, cmp_T score_cmp,
<a name="l00346"></a>00346        std::multimap&lt;my_float_t, rigid_align_vi, cmp_T&gt; *top_aligns,
<a name="l00347"></a>00347        <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> *lig_file, <span class="keyword">const</span> <span class="keywordtype">bool</span> frag_lig_filter,
<a name="l00348"></a>00348        <span class="keyword">const</span> size_t max_num_aligns, <span class="keyword">const</span> my_float_t score_cutoff,
<a name="l00349"></a>00349        <span class="keyword">const</span> <span class="keywordtype">bool</span> fine_tune_all, <a class="code" href="classSimSite3D_1_1DbaseSitemap.html">DbaseSitemap</a> *dset_site)
<a name="l00350"></a>00350   {
<a name="l00351"></a>00351     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::multimap&lt;my_float_t, rigid_align_vi, cmp_T&gt;::iterator
<a name="l00352"></a>00352       my_mmi;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>-&gt;<a class="code" href="classSimSite3D_1_1ModelSitemap.html#ee7e2c3271b9e278ce926db772cb71ad">revert</a>(score_method-&gt;uses_surface_mesh(),
<a name="l00355"></a>00355                     score_method-&gt;uses_hbond_surfaces());
<a name="l00356"></a>00356     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>-&gt;<a class="code" href="classSimSite3D_1_1ModelSitemap.html#962f9d9c2cd80c7266aa6adda57d0717">inverse_transform</a>(align-&gt;R, align-&gt;T,
<a name="l00357"></a>00357                                score_method-&gt;uses_surface_mesh(),
<a name="l00358"></a>00358                                score_method-&gt;uses_hbond_surfaces());
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     <span class="comment">// we may want multiple sets of match prints in the future?</span>
<a name="l00361"></a>00361     align-&gt;match_print.resize(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>-&gt;<a class="code" href="classSimSite3D_1_1Sitemap.html#88f86e7f2f8a1a69a6e34a1b6b942216">fit_points_size</a>());
<a name="l00362"></a>00362 
<a name="l00363"></a>00363     <span class="comment">// Check if we want to fine tune all candidate alignments at this level</span>
<a name="l00364"></a>00364     align-&gt;score = score_method-&gt;score(*<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>, *dset_site, &amp;(*align));
<a name="l00365"></a>00365     align-&gt;score = (align-&gt;score - <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a>) / <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a>;
<a name="l00366"></a>00366     <span class="keywordflow">if</span>(fine_tune_all){ 
<a name="l00367"></a>00367       <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#6c5e2282df3bb318cb939771eac92754">fine_tune_align</a>(dset_site, &amp;(*align));
<a name="l00368"></a>00368       <span class="keywordflow">if</span>(A_do_IK)
<a name="l00369"></a>00369         A_my_IK.<a class="code" href="classSimSite3D_1_1IK__tests.html#fac5e4fb00a62ec37cc72f53ebb20cfd">run</a>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">A_model</a>, *dset_site, &amp;(*align), <span class="stringliteral">"TEST_ID"</span>, std::cout);
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372     <span class="keywordflow">if</span>(score_cmp(score_cutoff, align-&gt;score)){
<a name="l00373"></a>00373 <span class="comment">//      std::cout &lt;&lt; "failed score cut off of " &lt;&lt; score_cutoff </span>
<a name="l00374"></a>00374 <span class="comment">//                &lt;&lt; " with a score of " &lt;&lt; align-&gt;score &lt;&lt; "\n";</span>
<a name="l00375"></a>00375       <span class="comment">// We may need to clean up the memory for the frag file</span>
<a name="l00376"></a>00376       <span class="keywordflow">if</span>(align-&gt;frag_file) <span class="keyword">delete</span>(align-&gt;frag_file);
<a name="l00377"></a>00377       align-&gt;frag_file = 0;
<a name="l00378"></a>00378       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="comment">// If we have the max number of alignments to keep and this score is</span>
<a name="l00382"></a>00382     <span class="comment">// worse than all of the previously stored alignemnts, discard it</span>
<a name="l00383"></a>00383     my_mmi pos = top_aligns-&gt;upper_bound(align-&gt;score);
<a name="l00384"></a>00384     <span class="keywordflow">if</span>(top_aligns-&gt;size() &gt;= max_num_aligns &amp;&amp; pos == top_aligns-&gt;end())
<a name="l00385"></a>00385       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387     <span class="comment">// If we have a ligand file, determine the ligand fragment in the</span>
<a name="l00388"></a>00388     <span class="comment">// binding site and check if enough ligand atoms are in the fragment</span>
<a name="l00389"></a>00389     <span class="keywordflow">if</span>(lig_file &amp;&amp; (frag_lig_filter || fine_tune_all)){
<a name="l00390"></a>00390       <span class="keywordtype">bool</span> lig_has_enough_atoms =
<a name="l00391"></a>00391         get_ligand_fragment(*lig_file, A_model-&gt;site_volume_estimate_handle(),
<a name="l00392"></a>00392                             A_model-&gt;interacting_atoms(), &amp;(*align));
<a name="l00393"></a>00393       <span class="keywordflow">if</span>(frag_lig_filter &amp;&amp; !lig_has_enough_atoms) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396     <span class="comment">// Insert the alignment into the top_aligns, and if we have an extra</span>
<a name="l00397"></a>00397     <span class="comment">// saved alignment, remove the alignment with the poorest score</span>
<a name="l00398"></a>00398     top_aligns-&gt;insert(pos, align_pair(align-&gt;score, align));
<a name="l00399"></a>00399     <span class="keywordflow">if</span>(top_aligns-&gt;size() &gt; max_num_aligns){
<a name="l00400"></a>00400       my_mmi last = top_aligns-&gt;end();
<a name="l00401"></a>00401       --last;
<a name="l00402"></a>00402       <span class="keywordflow">if</span>(last-&gt;second-&gt;frag_file) <span class="keyword">delete</span>(last-&gt;second-&gt;frag_file);
<a name="l00403"></a>00403       last-&gt;second-&gt;frag_file = 0;
<a name="l00404"></a>00404       top_aligns-&gt;erase(last);
<a name="l00405"></a>00405       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00409"></a>00409   }
<a name="l00410"></a>00410 
<a name="l00413"></a>00413 
<a name="l00422"></a>00422   <span class="keyword">template</span> &lt;<span class="keyword">class</span> score_T&gt; <span class="keywordtype">void</span>
<a name="l00423"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#1d8b66d8f4810212f8f8187c061d74f0">00423</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#1d8b66d8f4810212f8f8187c061d74f0">refine_best_alignment</a>(score_T *score_method, tier2_score_mmap *top_aligns, 
<a name="l00424"></a>00424                         <a class="code" href="classSimSite3D_1_1DbaseSitemap.html">DbaseSitemap</a>* dset_site, <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> *lig_file, 
<a name="l00425"></a>00425                         <span class="keyword">const</span> std::string&amp; db_struct_id, 
<a name="l00426"></a>00426                         <span class="keyword">const</span> std::string&amp; db_mol_id, 
<a name="l00427"></a>00427                         std::ostream&amp; rigid_results_out)
<a name="l00428"></a>00428   {
<a name="l00429"></a>00429     <span class="comment">// Get the best scoring alignment</span>
<a name="l00430"></a>00430     rigid_align_vi top_align = top_aligns-&gt;begin()-&gt;second;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     <span class="comment">// Refine the alignment</span>
<a name="l00433"></a>00433     A_model-&gt;revert(score_method-&gt;uses_surface_mesh(),
<a name="l00434"></a>00434                     score_method-&gt;uses_hbond_surfaces());
<a name="l00435"></a>00435     A_model-&gt;inverse_transform(top_align-&gt;R, top_align-&gt;T,
<a name="l00436"></a>00436                                score_method-&gt;uses_surface_mesh(),
<a name="l00437"></a>00437                                score_method-&gt;uses_hbond_surfaces());
<a name="l00438"></a>00438     top_align-&gt;score = score_method-&gt;score(*A_model, *dset_site, &amp;(*top_align));
<a name="l00439"></a>00439     top_align-&gt;score = (top_align-&gt;score - <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a>) / <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a>;
<a name="l00440"></a>00440     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#6c5e2282df3bb318cb939771eac92754">fine_tune_align</a>(dset_site, &amp;(*top_align));
<a name="l00441"></a>00441     <span class="keywordflow">if</span>(A_do_IK) 
<a name="l00442"></a>00442       A_my_IK.<a class="code" href="classSimSite3D_1_1IK__tests.html#fac5e4fb00a62ec37cc72f53ebb20cfd">run</a>(A_model, *dset_site, &amp;(*top_align), db_struct_id, std::cout);
<a name="l00443"></a>00443     
<a name="l00444"></a>00444     <span class="comment">// Clear the given map holding the "unrefined" alignments and insert</span>
<a name="l00445"></a>00445     <span class="comment">// the refined alignment and its score</span>
<a name="l00446"></a>00446     tier2_score_mmi aligns_iter = top_aligns-&gt;begin();
<a name="l00447"></a>00447     <span class="keywordflow">for</span>( ; aligns_iter != top_aligns-&gt;end(); ++aligns_iter)
<a name="l00448"></a>00448       <span class="keywordflow">if</span>(aligns_iter-&gt;second-&gt;frag_file){
<a name="l00449"></a>00449         <span class="keyword">delete</span>(aligns_iter-&gt;second-&gt;frag_file);
<a name="l00450"></a>00450         aligns_iter-&gt;second-&gt;frag_file = 0; 
<a name="l00451"></a>00451       }
<a name="l00452"></a>00452     top_aligns-&gt;clear();
<a name="l00453"></a>00453     top_aligns-&gt;insert(top_aligns-&gt;begin(), 
<a name="l00454"></a>00454                        align_pair(top_align-&gt;score, top_align));
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="comment">// Update ligand fragmentation if we have a ligand</span>
<a name="l00457"></a>00457     <span class="keywordflow">if</span>(lig_file){
<a name="l00458"></a>00458       get_ligand_fragment(*lig_file, A_model-&gt;site_volume_estimate_handle(),
<a name="l00459"></a>00459                           A_model-&gt;interacting_atoms(), &amp;(*top_align));
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461   }
<a name="l00462"></a>00462 
<a name="l00464"></a>00464   <span class="keywordtype">void</span>
<a name="l00465"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#4e0ef1c8fe1ed27a93385ec78ca35bf7">00465</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#4e0ef1c8fe1ed27a93385ec78ca35bf7">score_protein_ligand_interactions</a>(tier2_score_mmap *top_aligns)
<a name="l00466"></a>00466   {
<a name="l00467"></a>00467     <span class="comment">// Protein-ligand scoring </span>
<a name="l00468"></a>00468     tier2_score_mmi align;
<a name="l00469"></a>00469     <span class="keywordflow">for</span>(align = top_aligns-&gt;begin(); align != top_aligns-&gt;end(); ++align){
<a name="l00470"></a>00470       <span class="keywordflow">if</span>(!align-&gt;second-&gt;frag_file) <span class="keywordflow">continue</span>;
<a name="l00471"></a>00471        
<a name="l00472"></a>00472       <span class="comment">// Note: we are potentially scoring lots of fragments and other junk.</span>
<a name="l00473"></a>00473       <span class="comment">// A decent guess is to keep the same charges as are on the full ligand</span>
<a name="l00474"></a>00474       <span class="comment">// since the groups are likely to be similarly charged in a </span>
<a name="l00475"></a>00475       <span class="comment">// complementary ligand -- i.e. don't compute ligand charge_sums</span>
<a name="l00476"></a>00476       <a class="code" href="classSimSite3D_1_1ProtLigScore.html">ProtLigScore</a> frag_score(*<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">A_query_prot</a>, *(align-&gt;second-&gt;frag_file),
<a name="l00477"></a>00477                               <span class="keyword">true</span>, <span class="keyword">false</span>);
<a name="l00478"></a>00478       align-&gt;second-&gt;set_prot_lig_scores(frag_score.<a class="code" href="classSimSite3D_1_1ProtLigScore.html#3b141a7e5ba3c877356e268809133520">affiscore</a>(),
<a name="l00479"></a>00479                                          frag_score.<a class="code" href="classSimSite3D_1_1ProtLigScore.html#5d08bfc7c970cb20a8418452c70f676e">orientscore</a>(),
<a name="l00480"></a>00480                                          frag_score.<a class="code" href="classSimSite3D_1_1ProtLigScore.html#1f92dc0a2b0830b392f6f5648e6e316b">ligand_efficiency</a>());
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482   }
<a name="l00483"></a>00483 
<a name="l00485"></a>00485   <span class="keywordtype">void</span>
<a name="l00486"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#4adb8e45da74e0d142fd29e1b1f104dc">00486</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#4adb8e45da74e0d142fd29e1b1f104dc">handle_ligands</a>(tier2_score_mmap &amp;top_aligns, <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> *lig_file,
<a name="l00487"></a>00487                  <span class="keyword">const</span> std::string &amp;mol_id)
<a name="l00488"></a>00488   {
<a name="l00489"></a>00489     <span class="comment">// write ligands to file</span>
<a name="l00490"></a>00490     <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#14c7215836a55728fa4225078b31cad7">A_write_ligands</a>){
<a name="l00491"></a>00491       tier2_score_mmi align = top_aligns.begin();
<a name="l00492"></a>00492       <span class="keywordflow">for</span>(uint cnt = 1; align != top_aligns.end(); ++align, ++cnt)
<a name="l00493"></a>00493         <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#6c5bf42335a29f8d6b64c3d163bd79f6">write_ligands</a>(align-&gt;second-&gt;frag_file, lig_file, align-&gt;second-&gt;R,
<a name="l00494"></a>00494                       align-&gt;second-&gt;T, cnt, mol_id, A_proj_output);
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497     <span class="comment">// Delete the memory corresponding to the ligand</span>
<a name="l00498"></a>00498     tier2_score_mmi align = top_aligns.begin();
<a name="l00499"></a>00499     <span class="keywordflow">for</span>( ; align != top_aligns.end(); ++align){
<a name="l00500"></a>00500       <span class="keyword">delete</span> align-&gt;second-&gt;frag_file;
<a name="l00501"></a>00501       align-&gt;second-&gt;frag_file = 0; 
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503     
<a name="l00504"></a>00504     <a class="code" href="classSimSite3D_1_1ScoreMapBase.html#85708eaffffc9a4e36bbd7375b552586">run_external_scoring_method</a>(top_aligns.begin(), top_aligns.end(),
<a name="l00505"></a>00505                                 A_model-&gt;atoms_file_name(), mol_id,
<a name="l00506"></a>00506                                 A_proj_output);
<a name="l00507"></a>00507   }
<a name="l00508"></a>00508 
<a name="l00510"></a>00510   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00511"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#ec86b7fcea8af70b5b4e7cb7dc87383a">00511</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#ec86b7fcea8af70b5b4e7cb7dc87383a">report_alignments</a>(<span class="keyword">const</span> tier2_score_mmap top_aligns, <span class="keyword">const</span> <span class="keywordtype">bool</span> wrote_ligs,
<a name="l00512"></a>00512                     <span class="keyword">const</span> std::string &amp;db_struct_id, 
<a name="l00513"></a>00513                     <span class="keyword">const</span> std::string &amp;db_mol_id,
<a name="l00514"></a>00514                     std::ostream&amp; results_out)
<a name="l00515"></a>00515   {
<a name="l00516"></a>00516 
<a name="l00517"></a>00517     uint cnt = 1;
<a name="l00518"></a>00518     tier2_score_mmci align;
<a name="l00519"></a>00519     <span class="keywordflow">for</span>(align = top_aligns.begin(); align != top_aligns.end(); ++align, ++cnt){
<a name="l00520"></a>00520       align-&gt;second-&gt;write_score_fields(results_out, cnt, wrote_ligs, <a class="code" href="classSimSite3D_1_1ScoreMapBase.html#b6bfd4fcc3263c7ee1cc86c856cea184">ext_SF_id</a>,
<a name="l00521"></a>00521                                         db_struct_id, db_mol_id);
<a name="l00522"></a>00522       results_out &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524   }
<a name="l00525"></a>00525 
<a name="l00528"></a>00528 
<a name="l00531"></a>00531   <span class="keyword">virtual</span> <span class="keywordtype">void</span> 
<a name="l00532"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#6c5e2282df3bb318cb939771eac92754">00532</a>   <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#6c5e2282df3bb318cb939771eac92754">fine_tune_align</a>(<a class="code" href="classSimSite3D_1_1DbaseSitemap.html">DbaseSitemap</a>* search, rigid_align_obj *align)
<a name="l00533"></a>00533   {
<a name="l00534"></a>00534     std::cout &lt;&lt; <span class="stringliteral">"\n\n Inside fine tune align\n"</span>;
<a name="l00535"></a>00535     <span class="keyword">const</span> my_float_t RMSE_TOL = 0.05;
<a name="l00536"></a>00536     <span class="keyword">const</span> size_t N = 100;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     <span class="comment">// Get current correspondences</span>
<a name="l00539"></a>00539     my_float_t* query_pts = 0, *db_pts = 0;
<a name="l00540"></a>00540     size_t npts;
<a name="l00541"></a>00541     A_tier2_score_class.correspondences(*A_model, &amp;query_pts, &amp;db_pts, &amp;npts);
<a name="l00542"></a>00542     std::cout &lt;&lt; <span class="stringliteral">" Number of initial pt correspondences "</span> &lt;&lt; npts 
<a name="l00543"></a>00543               &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; std::endl;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     <span class="comment">// If the the alignment data class supports it, save the initial </span>
<a name="l00546"></a>00546     <span class="comment">// transformation, score, and features</span>
<a name="l00547"></a>00547     <span class="comment">//align-&gt;site_atomic_rmsd() ....</span>
<a name="l00548"></a>00548     <span class="keywordflow">if</span>(A_do_IK)
<a name="l00549"></a>00549       A_my_IK.<a class="code" href="classSimSite3D_1_1IK__tests.html#5748368e2908160b96bcabb654fdcbe6">compute_initial_atomic_rmsd</a>(A_model, *search, &amp;(*align));
<a name="l00550"></a>00550     align-&gt;save_rigid_alignment_vals();
<a name="l00551"></a>00551 
<a name="l00552"></a>00552     <span class="comment">// We require at least 3 correspondences to fully describe a 3D alignment</span>
<a name="l00553"></a>00553     <span class="keywordflow">if</span>(npts &lt; 3) <span class="keywordflow">return</span>;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     <span class="comment">// Save the initial alignment in the event we need to revert to it</span>
<a name="l00556"></a>00556     rigid_align_obj initial_align(*align); 
<a name="l00557"></a>00557 
<a name="l00558"></a>00558     
<a name="l00559"></a>00559 <span class="preprocessor">#if 0</span>
<a name="l00560"></a>00560 <span class="preprocessor"></span>      std::stringstream ofname_f;
<a name="l00561"></a>00561       ofname_f &lt;&lt; <span class="stringliteral">"blah_"</span> &lt;&lt; A_orient_num &lt;&lt; <span class="stringliteral">"_0"</span>;
<a name="l00562"></a>00562       A_model-&gt;binding_site_mesh_handle().write(ofname_f.str());
<a name="l00563"></a>00563       std::cout &lt;&lt; <span class="stringliteral">"Corresponds: 0\n"</span>;
<a name="l00564"></a>00564         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> zz = 0; zz &lt; npts; ++zz){
<a name="l00565"></a>00565           std::cout &lt;&lt; query_pts[3*zz + 0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00566"></a>00566                     &lt;&lt; query_pts[3*zz + 1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; query_pts[3*zz + 2] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l00567"></a>00567           std::cout &lt;&lt; db_pts[3*zz + 0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00568"></a>00568                     &lt;&lt; db_pts[3*zz + 1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; db_pts[3*zz + 2] &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00569"></a>00569         }
<a name="l00570"></a>00570 <span class="preprocessor">#endif</span>
<a name="l00571"></a>00571 <span class="preprocessor"></span>
<a name="l00572"></a>00572     <span class="comment">//model-&gt;binding_site_mesh_handle()-&gt;write("blah_0");</span>
<a name="l00573"></a>00573     my_float_t prev_RMSE = my_float_max;
<a name="l00574"></a>00574     <span class="keywordflow">for</span>(size_t n = 0; n &lt; N; ++n){
<a name="l00575"></a>00575 
<a name="l00576"></a>00576       <span class="comment">// Get most recent transformation </span>
<a name="l00577"></a>00577       Quaternion Q;
<a name="l00578"></a>00578       my_float_t T[3];
<a name="l00579"></a>00579       lse_3D_fit(query_pts, db_pts, npts, &amp;Q, T);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581       <span class="comment">// Clean up mem</span>
<a name="l00582"></a>00582       <span class="keywordflow">if</span>(query_pts) <span class="keyword">delete</span> [] query_pts;
<a name="l00583"></a>00583       <span class="keywordflow">if</span>(db_pts) <span class="keyword">delete</span> [] db_pts;
<a name="l00584"></a>00584       query_pts = 0;
<a name="l00585"></a>00585       db_pts = 0;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587       <span class="comment">// Apply the most recent transformation</span>
<a name="l00588"></a>00588       my_float_t R[9];
<a name="l00589"></a>00589       Q.get_ortho_rot_mat(R);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591       <span class="comment">// This is a very inelegant solution, but we need to concentrate our</span>
<a name="l00592"></a>00592       <span class="comment">// resources elsewhere at this point (rather than on numerics).</span>
<a name="l00593"></a>00593       <span class="comment">// The main issue we have been facing is with a small number of points</span>
<a name="l00594"></a>00594       <span class="comment">// 3  (the minimum required).  When we have a small number of points, </span>
<a name="l00595"></a>00595       <span class="comment">// sometimes too many of the corresponding points are the same;  in such </span>
<a name="l00596"></a>00596       <span class="comment">// a cases, the solution is degenerate and the roots of the characteristic</span>
<a name="l00597"></a>00597       <span class="comment">// equation contain a complex component.</span>
<a name="l00598"></a>00598       <span class="keywordflow">if</span>(std::isnan(T[0]) || std::isnan(T[1]) || std::isnan(T[2])){
<a name="l00599"></a>00599          std::cout &lt;&lt; <span class="stringliteral">"Fine tuning failed.\n"</span>; 
<a name="l00600"></a>00600          std::cout &lt;&lt; <span class="stringliteral">"Number of pairs of corresponding points: "</span> 
<a name="l00601"></a>00601                    &lt;&lt; npts &lt;&lt; <span class="stringliteral">"\n\n"</span>;
<a name="l00602"></a>00602          *align = initial_align;
<a name="l00603"></a>00603          <span class="keywordflow">return</span>;
<a name="l00604"></a>00604       } 
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="comment">//      std::cout &lt;&lt; "round #: " &lt;&lt; n &lt;&lt; "\n";</span>
<a name="l00607"></a>00607 <span class="comment">//      std::cout &lt;&lt; "Q: " &lt;&lt; Q.str() &lt;&lt; "\n"</span>
<a name="l00608"></a>00608 <span class="comment">//                &lt;&lt; "T: " &lt;&lt; T[0] &lt;&lt; " " &lt;&lt; T[1] &lt;&lt; " " &lt;&lt; T[2] &lt;&lt; "\n"; </span>
<a name="l00609"></a>00609       A_model-&gt;inverse_transform(R, T, A_tier2_score_class.uses_surface_mesh(),
<a name="l00610"></a>00610                                  A_tier2_score_class.uses_hbond_surfaces());
<a name="l00611"></a>00611 
<a name="l00612"></a>00612       <span class="comment">// Get current correspondences</span>
<a name="l00613"></a>00613       align-&gt;score = A_tier2_score_class.score(*A_model, *search, &amp;(*align));
<a name="l00614"></a>00614       my_float_t RMSE = 
<a name="l00615"></a>00615         A_tier2_score_class.correspondences(*A_model, &amp;query_pts, &amp;db_pts, &amp;npts);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 <span class="comment">//        std::cout &lt;&lt; "RMSE: " &lt;&lt; RMSE &lt;&lt; "\n" &lt;&lt; std::endl;</span>
<a name="l00619"></a>00619       <span class="keywordflow">if</span>(RMSE &lt;= RMSE_TOL) <span class="keywordflow">break</span>;    
<a name="l00620"></a>00620       <span class="keywordflow">if</span>(prev_RMSE - RMSE &lt; 1E-07) <span class="keywordflow">break</span>;
<a name="l00621"></a>00621       prev_RMSE = RMSE;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="preprocessor">#if 0</span>
<a name="l00624"></a>00624 <span class="preprocessor"></span>        std::stringstream ofname;
<a name="l00625"></a>00625         ofname &lt;&lt; <span class="stringliteral">"blah_"</span> &lt;&lt; A_orient_num &lt;&lt; <span class="stringliteral">"_"</span> &lt;&lt; n+1;
<a name="l00626"></a>00626         A_model-&gt;binding_site_mesh_handle().write(ofname.str());
<a name="l00627"></a>00627  
<a name="l00628"></a>00628       std::cout &lt;&lt; <span class="stringliteral">"\nCorresponds: "</span> &lt;&lt; n + 1 &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00629"></a>00629         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> zz = 0; zz &lt; npts; ++zz){
<a name="l00630"></a>00630           std::cout &lt;&lt; query_pts[3*zz + 0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00631"></a>00631                     &lt;&lt; query_pts[3*zz + 1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; query_pts[3*zz + 2] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l00632"></a>00632           std::cout &lt;&lt; db_pts[3*zz + 0] &lt;&lt; <span class="stringliteral">" "</span>
<a name="l00633"></a>00633                     &lt;&lt; db_pts[3*zz + 1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; db_pts[3*zz + 2] &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 <span class="preprocessor">#endif</span>
<a name="l00637"></a>00637 <span class="preprocessor"></span>    }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <span class="comment">// Get a single transformation that moves the dbase site to the query</span>
<a name="l00640"></a>00640     A_model-&gt;get_current_inverse_3D_transform(&amp;(align-&gt;Q), align-&gt;T);
<a name="l00641"></a>00641     align-&gt;Q.get_ortho_rot_mat(align-&gt;R);
<a name="l00642"></a>00642     align-&gt;score = (align-&gt;score - <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a>) / <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a>;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     <span class="comment">// Clean up mem</span>
<a name="l00645"></a>00645     <span class="keywordflow">if</span>(query_pts) <span class="keyword">delete</span> [] query_pts;
<a name="l00646"></a>00646     <span class="keywordflow">if</span>(db_pts) <span class="keyword">delete</span> [] db_pts;
<a name="l00647"></a>00647     query_pts = 0;
<a name="l00648"></a>00648     db_pts = 0;
<a name="l00649"></a>00649   }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp;
<a name="l00652"></a>00652   model_struct_id()
<a name="l00653"></a>00653   { <span class="keywordflow">return</span> A_model_struct_id; }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     tier1_SF A_tier1_score_class;
<a name="l00656"></a>00656     tier2_SF A_tier2_score_class;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <span class="keyword">protected</span>:
<a name="l00659"></a>00659     
<a name="l00660"></a>00660     <span class="comment">// protected for now -- testing</span>
<a name="l00661"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#13a5468270fa523e191d1428030fd015">00661</a>     tier1_score_cmp <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#13a5468270fa523e191d1428030fd015">A_tier1_score_cmp</a>;  
<a name="l00662"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f70ab6bb6b22b59758853f0326c8fece">00662</a>     tier2_score_cmp <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f70ab6bb6b22b59758853f0326c8fece">A_tier2_score_cmp</a>;  
<a name="l00663"></a>00663 
<a name="l00665"></a>00665     <span class="keywordtype">bool</span>
<a name="l00666"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#a2c37b383be18dec552610eacad948fa">00666</a>     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#a2c37b383be18dec552610eacad948fa">load_ligand</a>(<span class="keyword">const</span> std::string &amp;lig_fname, <span class="keyword">const</span> std::string &amp;atoms_fname,
<a name="l00667"></a>00667                 <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a> **ligand, std::string *struct_id, std::string *mol_id)
<a name="l00668"></a>00668     {
<a name="l00669"></a>00669       *ligand = 0;
<a name="l00670"></a>00670       std::string chaff;
<a name="l00671"></a>00671       get_path_and_struct_id(atoms_fname, &amp;chaff, struct_id);
<a name="l00672"></a>00672       <span class="comment">// Using a brain dead method for "get_path_and_struct_id" and</span>
<a name="l00673"></a>00673       <span class="comment">// passing in XXXXXX_rad.pdb</span>
<a name="l00674"></a>00674       *struct_id = struct_id-&gt;substr(0, struct_id-&gt;length() - 2);
<a name="l00675"></a>00675 
<a name="l00676"></a>00676       <span class="comment">// If the minimum fragment size is greater than zero, we require each</span>
<a name="l00677"></a>00677       <span class="comment">// dbase entry to have a valid ligand file</span>
<a name="l00678"></a>00678       <span class="keywordflow">if</span>(<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a> &gt; 0){
<a name="l00679"></a>00679         <span class="keywordflow">if</span>(lig_fname == <span class="stringliteral">"NONE"</span>){
<a name="l00680"></a>00680           message(std::string(<span class="stringliteral">"Skipping the site "</span>) + *struct_id + 
<a name="l00681"></a>00681                   <span class="stringliteral">" because it does not have a ligand.\n"</span>);
<a name="l00682"></a>00682           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00683"></a>00683         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(lig_fname == <span class="stringliteral">"NOT_FOUND"</span>){
<a name="l00684"></a>00684           message(std::string(<span class="stringliteral">"Skipping the site "</span>) + *struct_id + 
<a name="l00685"></a>00685                   <span class="stringliteral">" because the ligand file could not be found"</span>);
<a name="l00686"></a>00686           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00687"></a>00687         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!get_path_and_struct_id(lig_fname, &amp;chaff, mol_id)){
<a name="l00688"></a>00688           message(std::string(<span class="stringliteral">"Could not get ligand name and/or directory\n"</span>));
<a name="l00689"></a>00689           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691         *ligand = <span class="keyword">new</span> <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a>(lig_fname);
<a name="l00692"></a>00692         <span class="keywordflow">if</span>(!*ligand || (*ligand)-&gt;<a class="code" href="classSimSite3D_1_1CoordFile.html#62b4ac1cdf4bae7acb19ce63bfca599d">fail</a>()){
<a name="l00693"></a>00693           <span class="keywordflow">if</span>(*ligand) <span class="keyword">delete</span> *ligand;
<a name="l00694"></a>00694           *ligand = 0;
<a name="l00695"></a>00695           message(std::string(<span class="stringliteral">"Skipping the site map "</span>) + *struct_id + 
<a name="l00696"></a>00696                   <span class="stringliteral">" because we could not open the ligand file.\n"</span>);
<a name="l00697"></a>00697           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00698"></a>00698         }
<a name="l00699"></a>00699       }<span class="keywordflow">else</span>{
<a name="l00700"></a>00700         <span class="keywordtype">bool</span> have_lig = <span class="keyword">true</span>;
<a name="l00701"></a>00701         <span class="keywordflow">if</span>(lig_fname == <span class="stringliteral">"NOT_FOUND"</span>){
<a name="l00702"></a>00702           message(std::string(<span class="stringliteral">"Ignoring the ligand for "</span>) + *struct_id +
<a name="l00703"></a>00703                   <span class="stringliteral">" because the ligand file could not be found"</span>);
<a name="l00704"></a>00704           have_lig = <span class="keyword">false</span>;
<a name="l00705"></a>00705         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(lig_fname == <span class="stringliteral">"NONE"</span>){
<a name="l00706"></a>00706           message(std::string(<span class="stringliteral">"Ignoring the ligand for "</span>) + *struct_id + 
<a name="l00707"></a>00707                   <span class="stringliteral">" because it does not have a ligand.\n"</span>);
<a name="l00708"></a>00708           have_lig = <span class="keyword">false</span>;
<a name="l00709"></a>00709         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!get_path_and_struct_id(lig_fname, &amp;chaff, mol_id)){
<a name="l00710"></a>00710           message(std::string(<span class="stringliteral">"Ignoring the ligand for "</span>) + *struct_id +
<a name="l00711"></a>00711                   <span class="stringliteral">" because the ligand path could not be parsed"</span>);
<a name="l00712"></a>00712           have_lig = <span class="keyword">false</span>;
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         <span class="keywordflow">if</span>(have_lig){
<a name="l00716"></a>00716           *ligand = <span class="keyword">new</span> <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a>(lig_fname);
<a name="l00717"></a>00717           <span class="keywordflow">if</span>(!*ligand || (*ligand)-&gt;<a class="code" href="classSimSite3D_1_1CoordFile.html#62b4ac1cdf4bae7acb19ce63bfca599d">fail</a>()){
<a name="l00718"></a>00718             <span class="keywordflow">if</span>(*ligand) <span class="keyword">delete</span> *ligand;
<a name="l00719"></a>00719             *ligand = 0;
<a name="l00720"></a>00720             message(std::string(<span class="stringliteral">"Ignoring the ligand for "</span>) + *struct_id + 
<a name="l00721"></a>00721                     <span class="stringliteral">" because we could not open the ligand file.\n"</span>);
<a name="l00722"></a>00722           }
<a name="l00723"></a>00723         }
<a name="l00724"></a>00724       }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726       <span class="comment">//if(A_prot_lig_score &amp;&amp; *ligand) (*ligand)-&gt;calc_charge_sums();</span>
<a name="l00727"></a>00727       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00728"></a>00728     }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730     <span class="keywordtype">bool</span>
<a name="l00731"></a>00731     get_ligand_fragment(<span class="keyword">const</span> <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a>&amp; lig_file, 
<a name="l00732"></a>00732                         <span class="keyword">const</span> <a class="code" href="classSimSite3D_1_1BoundingVolume.html">BoundingVolume</a> &amp;site_vol, 
<a name="l00733"></a>00733                         <span class="keyword">const</span> <a class="code" href="classSimSite3D_1_1CoordFile.html">CoordFile</a>&amp; interacting_atoms, 
<a name="l00734"></a>00734                         <a class="code" href="classSimSite3D_1_1rigid__align__t.html">rigid_align_t</a> *align)
<a name="l00735"></a>00735     {
<a name="l00736"></a>00736       <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a>* tmp_frag = <span class="keyword">new</span> <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a>(lig_file, site_vol, interacting_atoms,
<a name="l00737"></a>00737                                         <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a>, align-&gt;<a class="code" href="classSimSite3D_1_1rigid__align__t.html#c19150913ee8369262f89abf3dba1839">R</a>, align-&gt;<a class="code" href="classSimSite3D_1_1rigid__align__t.html#c66d5098258a0e0296c47b3d438dfd40">T</a>);
<a name="l00738"></a>00738 
<a name="l00739"></a>00739       <span class="comment">// Check to be sure the ligand fragment has a reasonable number of </span>
<a name="l00740"></a>00740       <span class="comment">// atoms -- NOTE in the case of empty pocket searches we are </span>
<a name="l00741"></a>00741       <span class="comment">// assuming A_min_num_atoms is 0 (currently the definition of an </span>
<a name="l00742"></a>00742       <span class="comment">// empty pocket search)</span>
<a name="l00743"></a>00743       <span class="keywordflow">if</span>(tmp_frag-&gt;<a class="code" href="classSimSite3D_1_1mol2File.html#ac4b079f975345f69ad63b689f6bb3f5">num_heavy_atoms</a>() &lt; <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a>){
<a name="l00744"></a>00744         <span class="keyword">delete</span> tmp_frag;
<a name="l00745"></a>00745         tmp_frag = 0;
<a name="l00746"></a>00746       }<span class="keywordflow">else</span>{
<a name="l00747"></a>00747         align-&gt;<a class="code" href="classSimSite3D_1_1rigid__align__t.html#be34b21f5d3ef687d3e9213aca149eb6">frag_file</a> = tmp_frag;
<a name="l00748"></a>00748         <span class="comment">// Set the binary string for the ligand fragment atom flags</span>
<a name="l00749"></a>00749         align-&gt;<a class="code" href="classSimSite3D_1_1rigid__align__t.html#8a3efbcef870f53faa51a54e64918e17">frag_atoms_flags</a>.resize(lig_file.<a class="code" href="classSimSite3D_1_1CoordFile.html#acec4ad5461784995b4fb15bb97e34d4">num_atoms</a>());
<a name="l00750"></a>00750         std::vector&lt;bool&gt;::const_iterator f_src =
<a name="l00751"></a>00751            tmp_frag-&gt;<a class="code" href="classSimSite3D_1_1mol2File.html#27ca8161c7d240a8331a56912047dde0">frag_atoms_flags_beg</a>();
<a name="l00752"></a>00752         std::vector&lt;bool&gt;::iterator f_dest = 
<a name="l00753"></a>00753           align-&gt;<a class="code" href="classSimSite3D_1_1rigid__align__t.html#8a3efbcef870f53faa51a54e64918e17">frag_atoms_flags</a>.begin();
<a name="l00754"></a>00754         <span class="keywordflow">for</span>( ; f_src &lt; tmp_frag-&gt;<a class="code" href="classSimSite3D_1_1mol2File.html#a7662a32085ef964254c0f36285f9fb0">frag_atoms_flags_end</a>(); ++f_src, ++f_dest)
<a name="l00755"></a>00755           *f_dest = *f_src;
<a name="l00756"></a>00756         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00757"></a>00757       }
<a name="l00758"></a>00758       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761     ModelSitemap* 
<a name="l00762"></a>00762     model()
<a name="l00763"></a>00763     { <span class="keywordflow">return</span> A_model; }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765     <span class="keyword">const</span> my_float_t
<a name="l00766"></a>00766     mu()<span class="keyword"> const</span>
<a name="l00767"></a>00767 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a>; }
<a name="l00768"></a>00768 
<a name="l00769"></a>00769     <span class="keyword">const</span> my_float_t
<a name="l00770"></a>00770     sigma()<span class="keyword"> const</span>
<a name="l00771"></a>00771 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a>; }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     <span class="keyword">const</span> <span class="keywordtype">bool</span>
<a name="l00774"></a>00774     fine_tune_tier2_alignments()<span class="keyword"> const</span>
<a name="l00775"></a>00775 <span class="keyword">    </span>{ <span class="keywordflow">return</span> A_fine_tune_tier2_alignments; }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777     IK_tests&amp;
<a name="l00778"></a>00778     IK_tests_handle()
<a name="l00779"></a>00779     { <span class="keywordflow">return</span> A_my_IK; }   
<a name="l00780"></a>00780 
<a name="l00781"></a>00781     <span class="keyword">const</span> <span class="keywordtype">bool</span>
<a name="l00782"></a>00782     do_IK()<span class="keyword"> const</span>
<a name="l00783"></a>00783 <span class="keyword">    </span>{ <span class="keywordflow">return</span> A_do_IK; }
<a name="l00784"></a>00784 
<a name="l00785"></a>00785   <span class="keyword">private</span>:
<a name="l00786"></a>00786     <span class="comment">//tier1_SF A_tier1_score_class;</span>
<a name="l00787"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#74c601b35ff79d35a71f0fc155aeaab0">00787</a>     <a class="code" href="classSimSite3D_1_1ModelSitemap.html">ModelSitemap</a>* A_model; 
<a name="l00788"></a>00788     std::string A_score_method_str;
<a name="l00789"></a>00789     <a class="code" href="classSimSite3D_1_1IK__tests.html">IK_tests</a> A_my_IK;
<a name="l00790"></a>00790     <span class="keywordtype">bool</span> A_struct_id_field;
<a name="l00791"></a>00791     std::string A_model_struct_id;
<a name="l00792"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">00792</a>     my_float_t <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#e2a77ac5a0d9b23d4149c04dde1e445d">A_mu</a>;      
<a name="l00793"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">00793</a>     my_float_t <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3bd6d7e0444332b61f16bac0f5dad3ed">A_sigma</a>;   
<a name="l00794"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#7806e9477e19018757ac9095212e1263">00794</a>     my_float_t <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#7806e9477e19018757ac9095212e1263">A_score_cutoff</a>;  
<a name="l00795"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#896fa695aef8944e5a685ba3ef552b0c">00795</a>     size_t <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#896fa695aef8944e5a685ba3ef552b0c">A_max_num_aligns</a>;      
<a name="l00796"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#5412c0788cb1612caa586487861973c1">00796</a>     size_t <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#5412c0788cb1612caa586487861973c1">A_max_tier1_aligns</a>;    
<a name="l00797"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">00797</a>     uint <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#f68d236f77307b8d5e4eed409aa573ce">A_min_num_atoms</a>;   
<a name="l00798"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#c07f83e7959ea22d965c62791d68fef2">00798</a>     <span class="keywordtype">bool</span> <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#c07f83e7959ea22d965c62791d68fef2">normalize_scores</a>; 
<a name="l00799"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3d17d020c019cac00a83e36e22c1ffc6">00799</a>     std::string <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#3d17d020c019cac00a83e36e22c1ffc6">dbase_ligs</a>; 
<a name="l00800"></a>00800     std::string A_proj_output;
<a name="l00801"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">00801</a>     <a class="code" href="classSimSite3D_1_1PDBStructure.html">PDBStructure</a> *<a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#339bbd1f8e46f0bac4355109e02a5e80">A_query_prot</a>; 
<a name="l00802"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#14c7215836a55728fa4225078b31cad7">00802</a>     <span class="keywordtype">bool</span> <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#14c7215836a55728fa4225078b31cad7">A_write_ligands</a>;
<a name="l00803"></a>00803     <span class="keywordtype">bool</span> A_fine_tune_tier2_alignments;
<a name="l00804"></a>00804     <span class="keywordtype">bool</span> A_fine_tune_best_tier2_alignment;
<a name="l00805"></a>00805     <span class="keywordtype">bool</span> A_do_IK;
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <span class="comment">// for testing and messing around</span>
<a name="l00808"></a>00808     uint A_orient_num;
<a name="l00809"></a>00809 
<a name="l00811"></a>00811 
<a name="l00815"></a>00815     <span class="keywordtype">void</span> 
<a name="l00816"></a><a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#6c5bf42335a29f8d6b64c3d163bd79f6">00816</a>     <a class="code" href="classSimSite3D_1_1ScoreRigidAlignments.html#6c5bf42335a29f8d6b64c3d163bd79f6">write_ligands</a>(<a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a>* frag_file, <a class="code" href="classSimSite3D_1_1mol2File.html">mol2File</a>* lig_file, <span class="keyword">const</span> my_float_t* R,
<a name="l00817"></a>00817                   <span class="keyword">const</span> my_float_t* T, <span class="keyword">const</span> uint cnt,
<a name="l00818"></a>00818                   <span class="keyword">const</span> std::string struct_id, <span class="keyword">const</span> std::string output_dir)
<a name="l00819"></a>00819     {
<a name="l00820"></a>00820       lig_file-&gt;<a class="code" href="classSimSite3D_1_1CoordFile.html#6f632e32959f743ccc307a16e04c1a96">revert</a>();
<a name="l00821"></a>00821       lig_file-&gt;<a class="code" href="classSimSite3D_1_1CoordFile.html#e288ddf8441fe4652e6a1b90a4b5198c">transform</a>(R, T);
<a name="l00822"></a>00822       std::ostringstream fname;
<a name="l00823"></a>00823       fname &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">"/moved_ligands/"</span> &lt;&lt;  struct_id &lt;&lt; <span class="stringliteral">"_"</span>
<a name="l00824"></a>00824             &lt;&lt; std::setfill(<span class="charliteral">'0'</span>) &lt;&lt; std::setw(5) &lt;&lt; cnt &lt;&lt; <span class="stringliteral">"_l.mol2"</span>;
<a name="l00825"></a>00825       lig_file-&gt;<a class="code" href="classSimSite3D_1_1mol2File.html#050d5348e9f9a59de0949a66acab96de">write</a>(fname.str());
<a name="l00826"></a>00826       <span class="keywordflow">if</span>(frag_file){
<a name="l00827"></a>00827         fname.str(<span class="stringliteral">""</span>);
<a name="l00828"></a>00828         fname &lt;&lt; output_dir + <span class="stringliteral">"/ligand_fragments/"</span> + struct_id &lt;&lt; <span class="stringliteral">"_"</span>
<a name="l00829"></a>00829               &lt;&lt; std::setfill(<span class="charliteral">'0'</span>) &lt;&lt; std::setw(5) &lt;&lt; cnt &lt;&lt; <span class="stringliteral">"_f.mol2"</span>;
<a name="l00830"></a>00830         frag_file-&gt;<a class="code" href="classSimSite3D_1_1mol2File.html#050d5348e9f9a59de0949a66acab96de">write</a>(fname.str());
<a name="l00831"></a>00831       }
<a name="l00832"></a>00832     }
<a name="l00833"></a>00833  
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   };
<a name="l00836"></a>00836 }
<a name="l00837"></a>00837 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Apr 3 23:09:18 2012 for simsite3d by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
